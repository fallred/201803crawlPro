/*
 Navicat MySQL Data Transfer

 Source Server         : juejin
 Source Server Type    : MySQL
 Source Server Version : 80015
 Source Host           : localhost:3306
 Source Schema         : juejin

 Target Server Type    : MySQL
 Target Server Version : 80015
 File Encoding         : 65001

 Date: 27/02/2019 12:14:46
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article_tag
-- ----------------------------
DROP TABLE IF EXISTS `article_tag`;
CREATE TABLE `article_tag`  (
  `article_id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `tag_id` int(11) NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article_tag
-- ----------------------------
INSERT INTO `article_tag` VALUES ('5c6dc6465188256559172860', 46);
INSERT INTO `article_tag` VALUES ('5c6dc6465188256559172860', 61);
INSERT INTO `article_tag` VALUES ('5c737a976fb9a049a81ff5a7', 45);
INSERT INTO `article_tag` VALUES ('5c73a3966fb9a04a0605821b', 45);
INSERT INTO `article_tag` VALUES ('5c73a3966fb9a04a0605821b', 56);
INSERT INTO `article_tag` VALUES ('5c74d4b9e51d4512c37ea03b', 44);
INSERT INTO `article_tag` VALUES ('5c74d4b9e51d4512c37ea03b', 53);
INSERT INTO `article_tag` VALUES ('5c75d34851882564965edb23', 44);
INSERT INTO `article_tag` VALUES ('5c75d34851882564965edb23', 47);
INSERT INTO `article_tag` VALUES ('5c75d34851882564965edb23', 53);

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles`  (
  `id` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NULL,
  `href` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('59a611126fb9a0247a60efea', '强烈推荐--基于 vue2.x table 组件', '<article class=\"markdown-body entry-content\" itemprop=\"text\">\n                                \n                                <h2 data-id=\"heading-0\"><a id=\"user-content-介绍\" class=\"anchor\" href=\"#介绍\" aria-hidden=\"true\"></a>介绍</h2>\n                                <p>基于 vue2 的 组件。<a href=\"https://link.juejin.im?target=http%3A%2F%2Fdoc.huangsw.com%2Fvue-easytable%2Fapp.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">API文档以及实例</a></p>\n                                <h2 data-id=\"heading-1\"><a id=\"user-content-主要功能\" class=\"anchor\" href=\"#主要功能\" aria-hidden=\"true\"></a>主要功能</h2>\n                                <ol>\n                                    <li>自适应，可以随着浏览器窗口改变自动适应</li>\n                                    <li>固定列，表头固定</li>\n                                    <li>列宽拖动（默认支持）</li>\n                                    <li>排序，支持单个、多个字段排序</li>\n                                    <li>自定义列、自定义单元格样式、loading效果等</li>\n                                    <li>自带分页组件</li>\n                                </ol>\n                                <h2 data-id=\"heading-2\"><a id=\"user-content-安装\" class=\"anchor\" href=\"#安装\" aria-hidden=\"true\"></a>安装</h2>\n                                <pre><code><code>npm install vue-easytable --save-dev\n</code></code></pre>\n                                <h2 data-id=\"heading-3\"><a id=\"user-content-使用更多功能\" class=\"anchor\" href=\"#使用更多功能\" aria-hidden=\"true\"></a>使用（\n                                    <a href=\"https://link.juejin.im?target=http%3A%2F%2Fdoc.huangsw.com%2Fvue-easytable%2Fapp.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">更多功能</a>）</h2>\n                                <pre><code><code>import &apos;vue-easytable/libs/themes-base/index.css&apos;\nimport {VTable,VPagination} from &apos;vue-easytable&apos;\n\nVue.component(VTable.name, VTable)\nVue.component(VPagination.name, VPagination)\n</code></code></pre>\n                                <h2 data-id=\"heading-4\"><a id=\"user-content-效果展示\" class=\"anchor\" href=\"#效果展示\" aria-hidden=\"true\"></a>效果展示</h2>\n                                <p><a href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhuangshuwei%2Fvue-easytable%2Fblob%2Fmaster%2Fexamples%2Fimages%2Fvue-easytable.gif\" target=\"_blank\" rel=\"nofollow noopener noreferrer\"><img alt=\"vue-easytable\" style=\"max-width:100%;\" jj-img-width=\"980\" jj-img-height=\"600\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2017/8/30/cda91f0046b9a7619ab93144c7dceb95?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"800\" data-height=\"600\"></a></p>\n                                <h2 data-id=\"heading-5\"><a id=\"user-content-license\" class=\"anchor\" href=\"#license\" aria-hidden=\"true\"></a>License</h2>\n                                <p><a href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.opensource.org%2Flicenses%2Fmit-license.php\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">www.opensource.org/licenses/mi…</a></p>\n                            </article>', 'https://juejin.im/entry/59a611126fb9a0247a60efea');
INSERT INTO `articles` VALUES ('5c6dc6465188256559172860', '我的这套VuePress主题你熟悉吧', '<p>最近熬了很多个夜晚, 踩坑无数, 终于写出了用VuePress驱动的主题.</p>\n<blockquote>\n<p>只需体验三分钟，你就会跟我一样，爱上这款主题.</p>\n</blockquote>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzhhlwd%2Fvuepress-theme-indigo-material\" rel=\"nofollow noopener noreferrer\">vuepress-theme-indigo-material</a>, 已经发布到npm, 请客官享用~~</p>\n<h2 class=\"heading\" data-id=\"heading-0\">介绍</h2>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzhhlwd%2Fvuepress-theme-indigo-material\" rel=\"nofollow noopener noreferrer\">vuepress-theme-indigo-material</a> 的原主题是<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fyscoder%2Fhexo-theme-indigo\" rel=\"nofollow noopener noreferrer\">hexo-theme-indigo</a>, github 的 star 数高达<strong>2042</strong>, fork 的有<strong>451</strong>个, 它在静态博客网站中的应用处处可见.在这里首先感谢原作者.</p>\n<p>然而它的定位是仅支持 IE10+ 等现代浏览器。既然不需要支持老版本浏览器, 在前端发展迅猛的今天, 已经有许多技术能够让网址更快, 所以我用<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fvuejs%2Fvuepress\" rel=\"nofollow noopener noreferrer\">VuePress</a>来重写了它. 其实 indigo 的原作者已经在用 vuepress 重写了, 但是项目一直没有进展, 所以我接过了这个任务, 最后重写的效果是挺满意的.</p>\n<p>可以看看下面,本主题在我的有 51 篇博客笔记下, 部署在 github page, 在手机 4G 网络下的加载速度gif 图,网页加载速度非常快,更快的是,网页加载完成后,此后每个页面的打开速度,都是仿佛在点击本地文件.</p>\n<p>具体感受可以点击我的<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhhlwd.github.io%2F\" rel=\"nofollow noopener noreferrer\">博客网站</a>来亲身感受, 部署在 github page 下, 国内请可以点击码云的 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhhlwd.gitee.io%2F\" rel=\"nofollow noopener noreferrer\">page 地址</a></p>\n<p></p><figure><img alt=\"demo.gif\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/21/1690cd0a27c745cb?imageslim\" data-width=\"1280\" data-height=\"653\"><figcaption></figcaption></figure><p></p>\n<p>正如VuePress文档所说:</p>\n<blockquote>\n<p>每一个由 VuePress 生成的页面都带有预渲染好的 HTML，也因此具有非常好的加载性能和搜索引擎优化（SEO）。</p>\n</blockquote>\n<p>用 Lighthouse 来测试网站中, SEO 一直都是<strong>100</strong> ,打包后的大小也比起原主题小了许多.</p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fimgchr.com%2Fi%2Fk29TJO\" rel=\"nofollow noopener noreferrer\"></a></p><figure><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fimgchr.com%2Fi%2Fk29TJO\" rel=\"nofollow noopener noreferrer\"><img alt=\"k29TJO.md.png\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/21/1690ccfe90e24db3?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"680\" data-height=\"437\"><figcaption></figcaption></a></figure><p></p>\n<h3 class=\"heading\" data-id=\"heading-1\">巧妙之处</h3>\n<p>加载快的原因还在于是先在本地编译中把数据写进相应的 js 文件,</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">fs.writeFile(\n  <span class=\"hljs-string\">`<span class=\"hljs-subst\">${dataPath}</span>/search.js`</span>,\n  <span class=\"hljs-string\">`export default <span class=\"hljs-subst\">${<span class=\"hljs-built_in\">JSON</span>.stringify(search, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">2</span>)}</span>;`</span>,\n  error =&gt; {\n    <span class=\"hljs-keyword\">if</span> (error)\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;写入搜索search文件失败,原因是&apos;</span> + error.message);\n    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&apos;写入搜索search文件成功&apos;</span>);\n  }\n);\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>然后在网页被打开时, 在 vue.js 的生命周期 created 中, 结合 webpack 的 import()语法导入相应存放数据的 js 文件.</p>\n<pre><code class=\"hljs js copyable\" lang=\"js\">\n  created() {\n    <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-comment\">/* webpackChunkName: &quot;search&quot; */</span> <span class=\"hljs-string\">&quot;Data/search.js&quot;</span>).then(<span class=\"hljs-function\"><span class=\"hljs-params\">search</span> =&gt;</span> {\n      <span class=\"hljs-keyword\">this</span>.search = search.default;\n    });\n  },\n<span class=\"copy-code-btn\">复制代码</span></code></pre><p>webpack 会把代码分割,按需去利用 jsonp 去请求 js 文件, 这样我们就能在本地编译时整理所需的数据, 然后模拟了 web APP 开发的流程, 页面先到达呈现, 数据后请求.而不用怕我们所需要的数据和网页一起一次发过来,让网页加载速度缓慢</p>\n<p>最后利用 vue 强大的 MVVM, 因为数据都有了, 此后的页面几乎是立即渲染, 即点即开.</p>\n<p>这是我探索出来对没有后端的静态网站的一种很好的性能优化.</p>\n<h3 class=\"heading\" data-id=\"heading-2\">您换主题的理由</h3>\n<ul>\n<li>更快更小,</li>\n<li>改进我在一年的的使用中感受到的原主题一些交互和外观, 例如删除分享功能, 移除了打赏功能, 增加移动端文章目录导航等等</li>\n<li>更加容易自定义, vuepress 的主题和插件很灵活,只要您会 Vue, 就能利用相关知识修改原主题, 和平时工作中写的页面和 APP 差不多</li>\n<li>居于本地数据的全文搜索</li>\n<li>拥抱 vue, 然后能享用它的生态, 例如组件库, 本主题就利用了 element ui</li>\n<li>享用 vuepress 的 Markdown 拓展 , 例如在 Markdown 中 使用 Vue,自定义文章摘要</li>\n<li>理论上非常好的 SEO</li>\n<li>兼容 hexo 原主题写的 markdwon 文件, 不用修改即可搬迁移到本主题, 前提是您原来文件有遵守原主题的规则, 例如在文件顶部有包含 YAML front matte</li>\n</ul>\n<pre><code class=\"hljs bash copyable\" lang=\"bash\">---\ntitle: 【读书笔记】《JavaScript权威指南》第7章数组\ndate: 2018-11-08 04:10:03\ntags: [读书笔记, 《JavaScript权威指南》]\n---\n<span class=\"copy-code-btn\">复制代码</span></code></pre><ul>\n<li>已经发布到 npm, 只需要下载即可, 还提供一套模板文件结构, 下载依赖后立即可以使用, 还提供了相关操作的 shell 文件,双击即可,几分钟就能有自己的博客</li>\n<li>内置评论功能</li>\n<li>......</li>\n</ul>\n<h3 class=\"heading\" data-id=\"heading-3\">浏览器兼容性</h3>\n<p>由于博客面向的群体比较都是技术人员, 所以本主题只在最新版的谷歌浏览器和火狐浏览器测试无误</p>\n<p>vuepress 默认有编译一些对老版本浏览器的兼容, 具体控制请看它<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fvuepress.vuejs.org%2Fzh%2Fconfig%2F%23%25E6%25B5%258F%25E8%25A7%2588%25E5%2599%25A8%25E5%2585%25BC%25E5%25AE%25B9%25E6%2580%25A7\" rel=\"nofollow noopener noreferrer\">官网配置</a></p>\n<p>我写了很详细的文档, 赶快去体验一下<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzhhlwd%2Fvuepress-theme-indigo-material\" rel=\"nofollow noopener noreferrer\">vuepress-theme-indigo-material</a>吧, 如果觉得不错, 您能给我一个star吗?</p>\n<p>github地址:<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fzhhlwd%2Fvuepress-theme-indigo-material\" rel=\"nofollow noopener noreferrer\">github.com/zhhlwd/vuep…</a></p>\n', 'https://juejin.im/post/5c6dc6465188256559172860');
INSERT INTO `articles` VALUES ('5c737a976fb9a049a81ff5a7', '漫话：如何给女朋友解释什么是反向代理？', '<div><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d5f72f1bf?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"235\"></p><p>周末，我正在网上搜索简历，准备给团队招聘新人。这时候，女朋友回来了，看起来并不是很高兴。</p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d5f761f41?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"456\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d5fb2db8a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d5fc0f47b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"498\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d5feae098?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"504\"></p><p><b>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</b></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d61a668ef?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"498\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d73e388b6?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"494\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d74ca44f8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d74862f8a?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"496\"></p><h3 data-id=\"heading-0\">正向代理</h3><p>正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器(代理服务器)，为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。</p><p>这种代理其实在生活中是比较常见的，比如科学上网技术，其用到的就是代理技术。</p><p>有时候，用户想要访问某国外网站，该网站无法在国内直接访问，但是我们可以访问到一个代理服务器，这个代理服务器可以访问到这个国外网站。这样呢，用户对该国外网站的访问就需要通过代理服务器来转发请求，并且该代理服务器也会将请求的响应再返回给用户。这个上网的过程就是用到了正向代理。</p><div><img title class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d7598e4d1?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"518\"></div><p>这个过程其实和租房子很像。</p><p>租房子的时候，一般情况下，我们很难联系到房东，因为有些房东为了图方便，只把自己的房屋信息和钥匙交给中介了。而房客想要租房子，只能通过中介才能联系到房东。而对于房东来说，他可能根本不知道真正要租他的房子的人是谁，他只知道是中介在联系他。</p><p>这里面一共有三个角色，租客（用户）、中介（代理服务器）和房东（国外网站，目标服务器）。引入中介（代理服务器）的原因是用户无法联系上房东（用户无法访问国外网站）。</p><p><b>所以，正向代理，其实是&quot;代理服务器&quot;代理了&quot;客户端&quot;，去和&quot;目标服务器&quot;进行交互。</b></p><p>通过正向代理服务器访问目标服务器，目标服务器是不知道真正的客户端是谁的，甚至不知道访问自己的是一个代理（有时候中介也直接冒充租客）。</p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d76fa019d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"559\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d76c98838?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><h3 data-id=\"heading-1\">正向代理的用途</h3><p><b>突破访问限制</b> </p><p>通过代理服务器，可以突破自身IP访问限制，访问国外网站，教育网等。</p><p>即，租客可以通过中介，来解决无法联系上房东的问题。</p><p><b>提高访问速度</b></p><p>通常代理服务器都设置一个较大的硬盘缓冲区，会将部分请求的响应保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度。</p><p>即，中介手里留存了很多房源信息和钥匙，可以直接带租客去看房。</p><p><b>隐藏客户端真实IP</b></p><p>上网者也可以通过这种方法隐藏自己的IP，免受攻击。</p><p>即，房东并不知道租客的真实身份。PS：但是中介知道了，可能骚扰更多….</p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d8658b253?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"494\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d87a53260?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"560\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d89adfbb9?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"560\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d8a93052d?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"446\"></p><h3 data-id=\"heading-2\">反向代理</h3><p>反向代理（reverse proxy）：是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p><p>我们在租房子的过程中，除了有些房源需要通过中介以外，还有一些是可以直接通过房东来租的。用户直接找到房东租房的这种情况就是我们不使用代理直接访问国内的网站的情况。</p><p>还有一种情况，就是我们以为我们接触的是房东，其实有时候也有可能并非房主本人，有可能是他的亲戚、朋友，甚至是二房东。但是我们并不知道和我们沟通的并不是真正的房东。这种帮助真正的房主租房的二房东其实就是反向代理服务器。这个过程就是反向代理。</p><p>对于常用的场景，就是我们在Web开发中用到的负载均衡服务器（二房东），客户端（租客）发送请求到负载均衡服务器（二房东）上，负载均衡服务器（二房东）再把请求转发给一台真正的服务器（房东）来执行，再把执行结果返回给客户端（租客）。</p><div><img title class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d8e1570f8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"493\"></div>￼</div><div><b>所以，反向代理，其实是&quot;代理服务器&quot;代理了&quot;目标服务器&quot;，去和&quot;客户端&quot;进行交互。</b><p>通过反向代理服务器访问目标服务器时，客户端是不知道真正的目标服务器是谁的，甚至不知道自己访问的是一个代理。</p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d8ee0987b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"559\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d9ba58eb7?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"447\"></p><h3 data-id=\"heading-3\">反向代理的用途</h3><p><b>隐藏服务器真实IP</b></p><p>使用反向代理，可以对客户端隐藏服务器的IP地址。</p><p>即，租客并不房东知道的真实身份。</p><p><b>负载均衡</b></p><p>反向代理服务器可以做<a href=\"https://link.juejin.im?target=http%3A%2F%2Fmp.weixin.qq.com%2Fs%3F__biz%3DMzg3MjA4MTExMw%3D%3D%26amp%3Bmid%3D2247484661%26amp%3Bidx%3D2%26amp%3Bsn%3D03f3a7ec83599a31a1d638869b785597%26amp%3Bchksm%3Dcef5f743f9827e553b3923708ab4a00e990d0750759e81f3adf7261647a9191f6a5a0b878d12%26amp%3Bscene%3D21%23wechat_redirect\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">负载均衡</a>，根据所有真实服务器的负载情况，将客户端请求分发到不同的真实服务器上。</p><p>即，二房东发现房主本人很忙，于是找到房主的妻子帮忙处理租房事宜。</p><p><b>提高访问速度</b></p><p>反向代理服务器可以对于静态内容及短时间内有大量访问请求的动态内容提供缓存服务，提高访问速度。</p><p>即，二房东同样有房屋信息和钥匙。</p><p><b>提供安全保障</b></p><p>反向代理服务器可以作为应用层防火墙，为网站提供对基于Web的攻击行为（例如DoS/DDoS）的防护，更容易排查恶意软件等。还可以为后端服务器统一提供加密和SSL加速（如SSL终端代理），提供HTTP访问认证等。</p><p>即，二房东可以有效的保护房东的安全。</p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d9bf0eacb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316d9f2aaa69?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"443\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316da137f33e?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316daa415c88?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"496\"></p><h3 data-id=\"heading-4\">正向代理和反向代理的区别</h3><p>虽然正向代理服务器和反向代理服务器所处的位置都是客户端和真实服务器之间，所做的事情也都是把客户端的请求转发给服务器，再把服务器的响应转发给客户端，但是二者之间还是有一定的差异的。</p><p>1、<b>正向代理其实是客户端的代理</b>，帮助客户端访问其无法访问的服务器资源。<b>反向代理则是服务器的代理</b>，帮助服务器做负载均衡，安全防护等。</p><p>2、<b>正向代理一般是客户端架设的</b>，比如在自己的机器上安装一个代理软件。而<b>反向代理一般是服务器架设的</b>，比如在自己的机器集群中部署一个反向代理服务器。</p><p>3、<b>正向代理中，服务器不知道真正的客户端到底是谁</b>，以为访问自己的就是真实的客户端。而在<b>反向代理中，客户端不知道真正的服务器是谁</b>，以为自己访问的就是真实的客户端。</p><p>4、正向代理和反向代理的作用和目的不同。<b>正向代理主要是用来解决访问限制问题。而反向代理则是提供负载均衡、安全防护等作用。二者均能提高访问速度。</b></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316da187cbc8?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"502\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316db24ec320?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"441\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316db31114d1?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"500\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/25/1692316db9c3dece?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1080\" data-height=\"516\"></p><p><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/15/168f05901aea2fbb?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1242\" data-height=\"774\"><br></p></div><div><br></div><p><br></p>', 'https://juejin.im/post/5c737a976fb9a049a81ff5a7');
INSERT INTO `articles` VALUES ('5c73a3966fb9a04a0605821b', 'java基础（一）：谈谈java内存管理与垃圾回收机制', '<p>看了很多java内存管理的文章或者博客，写的要么笼统，要么划分的不正确，且很多文章都千篇一律。例如部分地方将jvm笼统的分为堆、栈、程序计数器，这么分太过于笼统，无法清晰的阐述java的内存管理模型；部分地方将jvm分为堆、栈、程序计数器、常量池、方法区，这么分，很全面，但是过于混乱，因为这些区域之间存在并列和包含关系，而最近再次刷《Java Thinking》这本书的时候，从新学习了关于内存模型的内容。基于上述原因，我决定来谈谈jvm虚拟机的内存划分。</p>\n<p>至于垃圾回收机制，个人觉得应该和内存管理一同讨论，所以在此，我也将内存回收机制拿出来进行一起讨论。</p>\n<p>本片博客的大致结构：1.内存区域；2.内存回收机制；3.垃圾回收器</p>\n<h1 class=\"heading\" data-id=\"heading-0\">1.内存区域</h1>\n<p>首先看看官方的内存模型图片：图片来自《Java虚拟机规范（第2版）》</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cc2f6b1fe7ba?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1052\" data-height=\"798\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-1\">1.1.程序计数器：</h2>\n<p><code>程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器</code>。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie方法，这个计数器值则为空（Undefined），由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，<code>程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。</code></p>\n<h2 class=\"heading\" data-id=\"heading-2\">1.2.栈</h2>\n<p><strong>栈分为虚拟机栈和本地方法栈</strong>，既然都是栈，那么就具有相同的特性：<code>私有的，线程安全，栈中存储了基本数据类型和对象的引用</code></p>\n<h3 class=\"heading\" data-id=\"heading-3\">1.2.1.java虚拟机栈</h3>\n<p><code>一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈</code>。实际上每个方法的调用相当于是栈帧的入栈已经出栈操作。局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</p>\n<h3 class=\"heading\" data-id=\"heading-4\">1.2.2.本地方法栈</h3>\n<p>本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：<code>虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的</code>，如调用C++，C#编写的方法。目前在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p>\n<h2 class=\"heading\" data-id=\"heading-5\">1.3.堆</h2>\n<p><code>堆是线程共享的，存储的是对象的实例</code>，有的地方写存储的是对象的实例和数组，实际上数组是特殊的类，那么数组也属于对象的实例。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC发生的主要场所，在虚拟机启动时创建，所以堆也成为GC堆，按照java垃圾回收的概念，堆又可以分为新生代和老年代，永久代（只有部分虚拟机中有永久代的概念，sun公司的HotSpot虚拟机就有，其它的一般没有，而hotSpot应用的比较广泛），其中新生代又可以分为Eden，From Survivor，To Survivor，其中每一块具体的作用在垃圾回收模块会详细介绍。原则上讲，所有的对象都在堆区上分配内存，但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的（通过-Xmx和-Xms控制）。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">1.4.方法区</h2>\n<p><code>方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</code>。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java堆区分开来。对于习惯在HotSpot虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot虚拟机的设计团队选择把GC分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9等）来说是不存在永久代的概念的。即使是HotSpot虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory来实现方法区的规划了。Java虚拟机规范对这个区域的限制非常宽松，除了和Java堆一样不需要连续的内存和可以选择固定大小或者可扩展外（通过设置permsize和MaxPermsize设置方法区的初始化大小和最大内存），还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun公司的BUG列表中，曾出现过的若干个严重的BUG就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存泄漏。 根据Java虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">1.5.常量池</h2>\n<p><code>运行时常量池（Runtime Constant Pool）是方法区的一部分</code>。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java虚拟机对Class文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只能在编译期产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。 既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常。</p>\n<h1 class=\"heading\" data-id=\"heading-8\">2.垃圾回收算法</h1>\n<p>java  语言中一个显著的特点就是引入了java回收机制，是c++程序员最头疼的内存管理的问题迎刃而解，<code>它使得java程序员在编写程序的时候不在考虑内存管理</code>。由于有个垃圾回收机制，java中的额对象不在有“作用域”的概念，只有对象的引用才有“作用域”。垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存；java语言规范没有明确的说明JVM 使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做两件基本事情：（1）发现无用的信息对象；（2）回收将无用对象占用的内存空间。使该空间可被程序再次使用。</p>\n<h2 class=\"heading\" data-id=\"heading-9\">2.1.引用计数法(Reference Counting Collector)</h2>\n<p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p>\n<h3 class=\"heading\" data-id=\"heading-10\">2.1.2优缺点</h3>\n<p>优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p>\n<p>缺点：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p>\n<h2 class=\"heading\" data-id=\"heading-11\">2.2.tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h2>\n<p>该算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p>\n<p>java中可作为GC Root的对象有</p>\n<p>1.虚拟机栈中引用的对象（本地变量表）</p>\n<p>2.方法区中静态属性引用的对象</p>\n<ol start=\"3\">\n<li>方法区中常量引用的对象</li>\n</ol>\n<p>4.本地方法栈中引用的对象（Native对象）</p>\n<p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收。分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。具体过程如下图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cc3ab2a45a4b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"990\" data-height=\"666\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-12\">2.3.compacting算法 或 标记-整理算法</h2>\n<p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cc3e072ce39b?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"992\" data-height=\"631\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-13\">2.4.copying算法(Compacting Collector)</h2>\n<p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cc41a9912c0c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1092\" data-height=\"642\"><figcaption></figcaption></figure><p></p>\n<h2 class=\"heading\" data-id=\"heading-14\">2.5.generation算法(Generational Collector)</h2>\n<p>分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation）和持久代，老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p>\n<h3 class=\"heading\" data-id=\"heading-15\">2.5.1.年轻代（Young Generation）</h3>\n<p>1.所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p>\n<p>2.新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p>\n<p>3.当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</p>\n<p>4.新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</p>\n<h3 class=\"heading\" data-id=\"heading-16\">2.5.2.年老代（Old Generation）</h3>\n<p>1.在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p>\n<p>2.内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p>\n<h3 class=\"heading\" data-id=\"heading-17\">2.5.3.持久代（Permanent Generation）</h3>\n<p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p>\n<p>目前大部分垃圾收集器对于新生代都采取Copying算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。</p>\n<p>而由于老年代的特点是每次回收都只回收少量对象，一般使用的是Mark-Compact算法。</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/27/1692cc46a256dbbd?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"654\"><figcaption></figcaption></figure><p></p>\n<p>当Eden区满的时候，会触发第一次Minor gc，把还活着的对象拷贝到Survivor From区；当Eden区再次出发Minor gc的时候，会扫描Eden区和From区，对两个区域进行垃圾回收，经过这次回收后还存活的对象，则直接复制到To区域，并将Eden区和From区清空。\n当后续Eden区又发生Minor gc的时候，会对Eden区和To区进行垃圾回收，存活的对象复制到From区，并将Eden区和To区清空\n部分对象会在From区域和To区域中复制来复制去，如此交换15次(由JVM参数MaxTenuringThreshold决定，这个参数默认是15)，最终如果还存活，就存入老年代。</p>\n<h1 class=\"heading\" data-id=\"heading-18\">3.垃圾回收（了解）</h1>\n<p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge</p>\n<p>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p>\n<p><strong>Serial收集器（复制算法)</strong></p>\n<p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p>\n<p><strong>Serial Old收集器(标记-整理算法)</strong></p>\n<p>老年代单线程收集器，Serial收集器的老年代版本。</p>\n<p><strong>ParNew收集器(停止-复制算法)</strong> </p>\n<p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p>\n<p><strong>Parallel Scavenge收集器(停止-复制算法)</strong></p>\n<p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p>\n<p><strong>Parallel Old收集器(停止-复制算法)</strong></p>\n<p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p>\n<p><strong>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</strong></p>\n<p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p>\n<p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p>\n<p><strong>Scavenge GC</strong></p>\n<p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p>\n<p><strong>Full GC</strong></p>\n<p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p>\n<p>1.年老代（Tenured）被写满</p>\n<p>2.持久代（Perm）被写满</p>\n<p>3.System.gc()被显示调用</p>\n<p>4.上一次GC之后Heap的各域分配策略动态变化</p>\n<p>1.静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</p>\n<p>2.各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</p>\n<p>3.监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fandy-zcx%2Fp%2F5522836.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/andy-zcx/p/…</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fwabi87547568%2Fp%2F5282892.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/wabi8754756…</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fblog.csdn.net%2Fyubujian_l%2Farticle%2Fdetails%2F80804708\" rel=\"nofollow noopener noreferrer\">blog.csdn.net/yubujian_l/…</a></p>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fdz-boss%2Fp%2F10219503.html\" rel=\"nofollow noopener noreferrer\">www.cnblogs.com/dz-boss/p/1…</a></p>\n', 'https://juejin.im/post/5c73a3966fb9a04a0605821b');
INSERT INTO `articles` VALUES ('5c74d4b9e51d4512c37ea03b', '我在淘宝做前端的这三年 — 第一年', '<p>转眼已经离职半年多了，早就想写一篇工作总结，但由于一直在准备英语考试，又需要处理结婚和房子装修，没想到一拖拖了半年。在淘宝做前端是我第一份签了劳动合同的工作，在这个人才济济的大公司里，接触了非常多的人和事物，也学到了非常多的东西、开阔了眼界。所以还是有必要做一个回顾和总结，一是自己备忘，二是或许对一些前端新人有所帮助，因为这篇文章会涉及到一些入职、职业规划、招聘、晋升、离职等方面的信息。</p>\n<p>由于篇幅过长，三年总结将会分三篇发布：</p>\n<p>第一篇（第一年）主要总结如何进入淘宝要用什么样的策略，如何站在老板视角看问题，我眼中的阿里文化等。</p>\n<p>第二篇（第二年）主要总结如何评审需求和推进项目，如何理解业务，飞冰项目的起源等。（预计将于 3 月 5 日左右发布，可以关注 <a target=\"_blank\" href=\"https://juejin.im/user/5af141466fb9a07abf7276cb/activities\" rel>我的掘金</a> 收到提醒）。</p>\n<p>第三篇（第三年）主要总结如何管理开源项目、推广项目，对招聘面试的思考，以及技术危机，我离职的原因，技术移民的考虑和未来规划等。（预计将于 3 月 12 日左右发布，可以关注<a target=\"_blank\" href=\"https://juejin.im/user/5af141466fb9a07abf7276cb/activities\" rel>我的掘金</a>）。</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-0\">来淘宝之前</h2>\n<p>时间先回到 2011 年下半年大一的一个晚自习，在思考自己未来想要从事计算机哪一个领域，当时找了张纸用坐标轴画了 <strong>市场前景</strong> 和 <strong>个人兴趣</strong> 两个轴，罗列技术领域和个人特点，筛选出了 安卓开发 和 网页制作 这两个方向。鉴于个人特性偏视觉和感觉而非逻辑而且高中一直在折腾各种源码搭网站，不太擅长底层的开发，最终选了网页制作，后来发现这个行业叫做前端开发。</p>\n<p>从那之后开始专注的学习，上课和自习都是看自己的技术书，在宿舍就是借助开发 WordPress 主题进行实践，并写很多文章（最早在 <a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fwww.qianxingzhem.com%2F\" rel=\"nofollow noopener noreferrer\">潜行者m</a> 博客上写）。当时看过一本很俗气的职业规划书，有个理论是挺认同的，<strong>专注一个领域三年可以成为高手，五年成为专家，十年成为高级专家</strong>。由于我的大学一般，分析下来能竞争的就是开发经验了，如果专注开发三年，毕业时的开发经验或许可以提升竞争力跟名校竞争一下。所以之后能逃课就逃课，绝大部分时间用来学习前端，再后来进入两个外包团队做项目，切了几十个整站项目，锻炼了各种前端基础技能同时还实现了经济独立。</p>\n<p>当时各种技术团队都有博客，淘宝 UED 博客算是最大最棒的一个，自然也成了我的梦想团队。大二下学期就开始关注秋季校招并在线做了下题看了看流程为大三做准备（其实有能力的同学大二到大三的假期也是可以去淘宝实习的）。大三继续疯狂写博客来提升一些名气，功夫不负有心人，终于引来了前辈的邀请：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/26/169285ef01ab6027?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"720\" data-height=\"412\"><figcaption></figcaption></figure><p></p>\n<p>“希望我能考虑下。” 还需要考虑啥？？我做梦都能笑醒了，马上联系过去告诉了目前的一些情况，并在后续知道春季实习生招聘计划后让他帮忙进行了内推，之后两个技术电面就通过了可以去实习了，可以算是相当顺利了。当时也有投一批二线互联网公司做兜底，本来觉得囊中取物，没想到里面有些公司很多简历关居然都挂了。感觉面试和找工作，运气成分其实挺大的。</p>\n<p>在这段经历中，我深刻的感受到了“机会总是留给有准备的人”这句话，虽然看起来挺俗的。运气固然重要但如果没有提前思考规划和学习也是很难抓住的。<strong>计算机行业有个好处就是技术水平高于一切，对于学校不好或者专业不符的同学也是有机会的，关键还是看兴趣持久不持久。</strong></p>\n<h2 class=\"heading\" data-id=\"heading-1\">正式入职淘宝</h2>\n<p>在淘宝的第一年并不是从 2015 年 7 月毕业开始的，由于我觉得周围同事都会很厉害，为了早早熟悉工作情况，15 年 3 月多过完年我就赶紧申请离校来淘宝继续实习，只在快毕业那段时间，请假几天返校处理毕设和合影等。其实普通学校也有一些优势，比较容易好说话，跟老师申请后经过老师反复确认淘宝不是一个诈骗公司后，就放行了。</p>\n<p>一回去实习，发现之前实习的团队居然拆了（第一次体会到“变化“），自己从基础架构挪到淘宝交易团队了，跟着师兄做购物车，后来还没正式签约就开始独立负责淘宝购物车业务，这时候要是出了什么事情背锅，是真的临时工。</p>\n<p>得益于“笨鸟先飞”，早在劳动合同签约之前就开始独立负责业务线，很多同届同学毕业才开始由师兄带领熟悉业务，所以在签约三个月左右的转正面试上，我有很多内容可以汇报。也正是因为这样，事后 HR 姐姐说我的分享在团队里算是比较好的，后面组织了一期新同学分享会，让我又做了一次“转正面试”分享。<strong>大力是可以出奇迹的，笨鸟真的要想办法先起飞。</strong></p>\n<h2 class=\"heading\" data-id=\"heading-2\">淘宝购物车业务</h2>\n<p>这个阶段基本上就是跟着 PD 走，来需求就评审，评完了就尽快做，做好了就测试，没问题就上线，基本上像阿甘一样。毕竟这种核心系统挺稳定的，需求迭代节奏也比较缓慢。</p>\n<p>直到 15 年双十一的一个需求，自己才第一次感觉到自己的工作价值。那是 15 年 10 月国庆后，双十一需求都基本做完了，而且快要进行全链路压测和封网了。这时候一个推荐算法团队的人找过来希望新增一个需求，算法接口都已经开发完成了需要前端做界面对接上去。由于早已经过了需求窗口期，完全可以直接拒掉，由于只涉及到前端部分，PD 将这个需求转给我自己评估，并给出建议如果不影响其他需求和稳定性并且来得及就做，来不及就不做。</p>\n<p>这个需求是当购物车某个商品由于库存或者状态失效后，出现一个“查找相似商品”的按钮，点击可以推荐相似商品快速加购。我看了下这个需求非常合理而且必要，因为双十一当天库存消耗非常快，很多来不及下单的商品可能迅速库存为零失效，但自己又很需要这个商品，直接有个入口迅速加购相比重新搜索的确方便太多。所以接下了这个任务，并加班加点对接开发，最终在封网前三天完成测试并发布。</p>\n<p>双十一复盘之后，收到了推荐算法团队同事发来的感谢邮件，加了这个功能双十一当天购物车的推荐量居然是平时购物车的几十或者几百倍（具体数字记不清了，但是很大），因为购物车原本只有最下面一个小推荐坑位平时推荐量不是很大。我按照比例简单计算了下，加的这个功能可能在双十一当天帮了几百万人快速加购，想想还是挺有成就感的。这个功能后来保留下来了，hover 就可以在右边出现：</p>\n<p></p><figure><img class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2019/2/26/169285ef01b2c785?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"720\" data-height=\"374\"><figcaption></figcaption></figure><p></p>\n<p>交易业务并不好做，因为是淘宝核心平台，很多业务线都有需求定制，代码里业务逻辑十分复杂，而且还要小心维护避免改坏了，特别害怕出现问题，因为一旦出问题可能就是 P1 级别故障，年终奖和晋升机会肯定是没了的。整个双十一或者大促期间都需要 on call，一接到电话需要马上起床开始处理。</p>\n<p>这一年大促关于图标有一些小故事，一开始设计将双十一标放在了商品图片上面，但被评审调整到文字前面去了。原来有些商家会比较鬼，自己在商品图片上 P 一个双十一标，以假乱真。然后双十一零点一过逍遥子突然发下通知，要求淘宝全链路换掉双十一的标。原来淘宝标跟双十一标有点像，但双十一属于天猫，淘宝并不能使用，于是设计师马上做出一套新的淘宝嘉年华 Icon，全链路各种发布换标。由于交易链路太重要，所以先改好代码，到了六点下单低峰才发布修正。原来一个小图片背后关系到了大量商家的利益，因为天猫商家参加双十一需要各种备货和审核，而且用户也根据这个图标判断哪些是参加双十一活动的商品，这时候两个一样的商品，有标和没标，销量可能差距巨大。开始觉得业务还是挺有意思的。</p>\n<p>做基础业务，压力还是很大的，害怕风险和线上问题，还不能延期。因为你延期了，很可能下面业务的促销活动就延期了，这可是非常大的问题。还好做完双十二就开始交接业务（第二次变化），淘宝交易前端交接给其他前端团队了。</p>\n<p>购物车和交易这块业务，我学习到了很多：</p>\n<ol>\n<li><strong>规范的开发流程</strong>：淘宝交易是淘宝最老的业务，也是平台方地位最高，所以交易线制定了很规范的排期会制度和发布制度，如果一个需求没赶上排期或者发布点，不管你多么重要，一律延期到下个发布点。因为交易系统本身的稳定性是最关键的。</li>\n<li><strong>线上问题无小事</strong>：交易由于用户量大、涉及关键链路，一旦出现线上问题，影响用户非常广，很可能产生重大故障。所以做交易的同学，都会特别小心谨慎，关注线上情况，发现小问题也要尽快修复。而后来接触了很多其他业务，线上的小 Bug，如果不影响使用就暂时先不管了。这个时期也搞了一些发布安全相关的事情，比如一个 Checklist <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fyujiangshui%2Ffront-end-code-checklist\" rel=\"nofollow noopener noreferrer\">github.com/yujiangshui…</a> （不过后来没有更新过了，有些点已经过时了，找时间我再更新下）。</li>\n<li><strong>Debug 和阅读代码能力</strong>：由于系统比较复杂，代码很多业务逻辑，想要绕开陷阱就需要仔细阅读代码和 Debug。有时虽然一个小需求，但是要前后 Debug 很多逻辑，确定这里没问题才能改。</li>\n</ol>\n<p>得益于这段时期学到的东西，我在知乎上回答了一些关于 Debug 的问题：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F38621456%2Fanswer%2F77255054\" rel=\"nofollow noopener noreferrer\">研究学习javascript框架或jquery插件的正确姿势是什么？</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F19793863%2Fanswer%2F124727423\" rel=\"nofollow noopener noreferrer\">哪些 JavaScript 框架（库）的源代码最值得阅读和学习？</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F32267297%2Fanswer%2F148656474\" rel=\"nofollow noopener noreferrer\">研究js框架源码用处真的大么？</a></li>\n</ul>\n<h2 class=\"heading\" data-id=\"heading-3\">无线交易业务</h2>\n<p>购物车是主线业务，支线业务当时是由师兄带领做无线交易的几个页面。当时是用 React 来开发这个项目，用了 reflux 等。当时应该算是淘宝最初用 React 的几个业务，主要是为了调研这个技术。</p>\n<p>其实<strong>大公司相比小公司更愿意也更容易尝试和应用新技术</strong>。因为一旦有了开发效率或者性能提升，给业务会带来巨大提升，也有足够的人力来研究，也有非常多的新业务可以来尝试。</p>\n<p>我们团队后来研发开源了 React Web（ <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Ftaobaofed%2Freact-web\" rel=\"nofollow noopener noreferrer\">github.com/taobaofed/r…</a> ） 项目，这个业务算是一个踩坑落地项目，用来发现一些问题。比较可惜的是，没过几个月，手机淘宝去掉了 React Native 并换成了 Weex，所以这一套对公司就没什么意义了，所以就停止了维护。不过一些经验积累，及时调头，老板又带人开发开源出来了 rax （ <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Falibaba%2Frax\" rel=\"nofollow noopener noreferrer\">github.com/alibaba/rax</a> ）。</p>\n<p>所以看一个大公司的开源项目是否会长期维护，看看他们内部的使用情况就可以了。像 Weex 这种，再怎么说也是会长期维护下去，因为它已经十分融入在手机淘宝里面。无数的页面和应用，都是基于 Weex 开发的。</p>\n<h2 class=\"heading\" data-id=\"heading-4\">淘宝海外业务</h2>\n<p>时间到了 2016 年初，交接完淘宝交易业务之后，我开始接手淘宝海外业务。淘宝海外业务是面向海外非大陆淘宝用户的业务，其实主要面向香港、台湾、东南亚等地区用户。</p>\n<p>由于面向国外，淘宝需要做很多改造，比如很多商品（生鲜、法禁品）等不能运输需要过滤、繁简体等国际化语言处理还有下单配送地址支持海外集运等。因此在建立业务时期，基本上就是把淘宝核心业务 fork 了一遍，拿来改造了下自己维护。</p>\n<p>淘宝海外首页是自己利用 TMS （运营平台）搭建、统一吊顶也是自己特殊定制的（增加国际化选项）、商品详情页是 Node 应用做的前后端分离、交易链路也自定义了一些样式和组件（比如海外集运）。相当于原本整个淘宝的核心链路，搞了一个微缩版本。</p>\n<p>做这段工作算是比较爽的，一个人负责一个微缩版本的淘宝的前端，有利于了解整个淘宝的业务链路和很多淘宝业务的代码。然后为了沟通方便，我把工位搬到业务方办公区，整片包括运营、产品、设计、技术等都在一起。当然也没有交易那种排期规则，如果有什么需求和会议，随时沟通开始做效率挺高，感觉像是创业公司，我很喜欢这种工作氛围。此外还有三个外包同学参与这个项目，由我分配工作，这让我有了一点“小老板”视角并得出结论：<strong>原来你的老板可能真的比你更了解你</strong>。</p>\n<p>由于这三位同学协助我工作，他们的工作能力和代码质量直接关系了我的工作量，所以我每周拿出一个小时做 Code Review and Share，在会议室让大家各自找一段本周写的比较好的代码出来分享，然后我也会找一段分析下好的地方和不好的地方。并且鼓励他们在阿里内部 ATA 平台写文章做分享，因为技术好的外包是可能转正的，这或许是个加分项。紧密工作一段时间后，<strong>很容易就看出这几位同学的能力和学习积极性的区别，再加上工作完成情况，可以说是对他们的能力看的比较清楚。</strong></p>\n<p>但仔细回顾一下，<strong>我跟平级的同事之间，其实是很难有所比较的</strong>。因为我们各自做的事情不同，而且也不会在意别人的优点或者缺点，更不会去“教育”或者“指点”平级同事应该怎么做。但是<strong>老板视角就非常清晰了，他需要对手下人的结果负责，所以会关注进度和进展，同时也十分容易做横向对比，可以说是可以十分清晰的看出一个人的水平。</strong> 老板为了自己晋升，也会关注手下的晋升，所以也会去指出一些问题。这个体验给我了很多思考：</p>\n<ol>\n<li><strong>跟对老板比做对事情重要</strong>：好的老板愿意去培养下属，指出问题。有能力的老板才能给下属更高的成长空间。很幸运的是我有这样一个老板（元彦）。</li>\n<li><strong>不用试图耍心机或者邀功、抢功</strong>：这些伎俩只能欺骗你自己，老板视角看的一清二楚。</li>\n<li><strong>认真记下老板的建议，多多反思</strong>：几乎所有人接受到批评，第一反应都是去反驳。但在职场上，老板一般是不会害你的（因为有晋升等利益相关）。这可能就是老板比你更懂你的地方，他能从一个更有经验的外部视角来看你的方案你做的事情。</li>\n<li><strong>遇到“不公”先想想自己</strong>：机会是有限的，为什么老板会把晋升机会、好的工作机会给某个人而不是你？先不要抱怨不公，想想为什么。</li>\n<li><strong>抓住机会多跟老板交流</strong>：基本上每周周会上，我都会提出来一些手头上一些比较棘手的问题或者对团队未来新动向的疑问，来学习下老板是什么样的解决思路。</li>\n</ol>\n<p>有些人可能会觉得老板比自己笨，但其实老板的老板并不是傻子，老板之所以成为你老板，肯定是有很多原因的，学习到了你老板的长处，有一天你才可能登上这个位置。</p>\n<p>所以说做事情要多站在老板的视角去思考，听取老板的建议并时常反思。如果的确有问题，为什么有这个问题？怎么解决？如果没有这个问题，为什么会被老板误以为有这个问题？</p>\n<h2 class=\"heading\" data-id=\"heading-5\">戏剧性的淘宝海外业务交接</h2>\n<p>有一天开了个需求评审会，结束之后一群运营就去了一个会议室。我以为还要继续开就跟进去了。进去之后才发现他们在通过一个商家录屏看 Lazada 的后台操作和有什么功能，算是一种竞品调研。我觉得这跟前端功能也有关系，就留下来一起看了下。</p>\n<p>没想到过了几天，突然就从外面看到新闻，阿里巴巴收购了 Lazada。没想到又过了一段时间，老板就开始让我处理交接任务，将把这个业务转出去。同时我来负责新的达人平台和内容平台的前端。再后来就听说整个淘宝海外业务就解散了，一些开发去 Lazada 做开发了，有的运营去了天猫，有的去了其他业务。</p>\n<p>其实阿里集团下包括 AliExpress 也是主打国际化，不过是偏欧美、俄罗斯的，Lazada 是偏东南亚地区。阿里巴巴高层分享国际化战略也强调过，不管做国际化的业务你叫什么名字，吃下来大部分，你就是阿里巴巴国际化代表。显然淘宝海外没有打败 Lazada，所以干脆用钱把 Lazada 买下来了。</p>\n<p><strong>换句话说，如果我们真的是创业公司，不管之前怎么努力，现在已经死了。</strong></p>\n<p>至此，亲身经历了三次重大变化，可以说是特别了解阿里“拥抱变化”的文化了。都说船大难掉头，其实感觉并不是这样。每年阿里都会调整业务归属，如果做不好可能就砍掉或者换一拨人来做。好处是快速试错持续前进，坏处就是一些研究和积累浪费了。我在淘宝海外主要研究了前端国际化的一些方案，还出去做了《基于 React 的国际化方案探索》的分享、写了<a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Ftaobaofed.org%2Fblog%2F2016%2F03%2F21%2Finternationalization%2F\" rel=\"nofollow noopener noreferrer\">《淘宝前端国际化方案探索》</a>以及回答了一些国际化相关的问题（<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F21980689%2Fanswer%2F93615123\" rel=\"nofollow noopener noreferrer\">zh-cn 与 zh-hans 是什么关系、有什么区别？</a>），但换了业务之后，这些知识就基本没有在后续业务中用到过了。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">阿里文化与高管分享</h2>\n<p>新入职同学会脱产有百阿（百年阿里）和百技（百年技术）培训，一个是价值观培训，一个是技术培训。在百阿大分享时，非常幸运，马总有空给我们这批新人做的分享。此外，HR 姐姐还会不时组织一些高管见面会帮助大家成长。这里可以简单分享一些我印象很深刻的点，在实际工作生活中也很必备：</p>\n<ol>\n<li><strong>诚信第一</strong>：阿里巴巴本身是商业公司，商业诚信第一，所以这是阿里巴巴的红线。小到虚假报打车发票，大到私下勾结商家，抓到必开然后加入黑名单，严重的送监狱。在阿里有句话，因为信任所以简单，所以权限放的比较开，要求必须有诚信。</li>\n<li><strong>公司里面薪资保密</strong>：薪资保密也是阿里的红线，公开讨论或者公布，会被开掉。这是源于最初马云创业时，筹集那 50 万初始资金那件事情。马总分享时说当时要求大家把自己闲钱拿出来，多少无所谓，不记名互相不能知道。时至今日马总也不知道究竟谁出了多少钱。因为人性是很脆弱的，一旦相互知道了，不可避免的就出现利益分配争端，也可能不再按照能力提拔。十八罗汉的关系可能很快就因为利益崩掉了。回归现实，影响一个人薪资的因素太多了，如果你知道你同事比你高，干活还比你少，你可能很难再正常工作。</li>\n</ol>\n<p>有一次高管见面会，邀请了玄难给我们做分享，给了我很多启发。他先介绍了他的工作经验，可以说是非常丰富了，前后端都做过，这么高 P 的技术专家在分享中举例用的前端名词挺专业的。主要收获：</p>\n<ol>\n<li><strong>不要经常换工作，做一份工作通常 3-4 年才会有所沉淀，对这个领域非常了解。</strong> 换工作的原因一定是追求更高的目标，而不是工作中遇到了困难想要逃避或者追求涨薪。越是遇到困难越要解决困难才可能有成长，逃避困难，换了工作仍然会遇到。技术的深度会跟薪资挂钩正比，即便是通过跳槽涨薪，没有技术实力压住泡沫还是会破。</li>\n<li><strong>在 IT 行业，工作和兴趣要尽可能贴合，可以发挥最大效果。</strong> 假如工作内容是一条线，兴趣是是一条线，这两条线的夹角越小，干活又轻松成果又多。如果这两条线是直角，两边可能都很痛苦，建议调整。</li>\n<li><strong>牛逼的架构师一定是业务、前后端各种技术栈全部有很深的理解。</strong> 不懂业务或者不懂前端只懂后端，都很难站在一个更高的视角来整体看问题和设计架构。因为系统是一个整体，有一部分不懂或者不关心，就可能成为系统的短板。</li>\n</ol>\n<p>我也趁机问了两个我比较感兴趣的问题：</p>\n<ol>\n<li>架构师日常工作是什么？答：一半时间四处听方案，评审架构方案可行性和合理性，并查看落地情况；一半时间用来制定目标管理人才以及招聘。</li>\n<li>对你影响最大的一本书或者技术是什么？答：编译原理。</li>\n</ol>\n<p>百阿培训时，一位讲师在讲关于抓住用户需求和关键点时也问了我们一个有趣的问题：<strong>如何用一句话让老板帮你晋升？</strong> 有人说我工作努力，晋升后会更努力。有人说我的实力足够晋升了，不晋升我就跑路了。其实都不对，讲师的答案是“<strong>帮我晋升，老板你才能晋升</strong>”。其实老板也需要晋升，但是一个团队的结构通常需要一个金字塔形状的结构。比如老板是 P6 带领一堆 P5，今年很多 P5 晋升到了 P6 那么老板显而易见很快要升 P7 了，不然金字塔结构就不稳定了。但一个 P7 带领一堆 P5 而且 P5 没有晋升迹象，那么可以遇见未来两三年都很难升 P8。从这个方面也可以看到，老板才是最可能对你好的人，你的成绩也关乎他的成绩。</p>\n<h2 class=\"heading\" data-id=\"heading-7\">第一年总结</h2>\n<p>到了 2016 年 4 月，第一财年结束了。在这一年，技术能力进步很多，从之前 jQuery 栈转到 KISSY 再到 React 并且具备了一定的 Debug 能力，结合之前阿里全网升级 HTTPS （当时作为临时工，升级了不少淘宝老系统代码）、淘宝交易和淘宝海外，阅读了很多很多代码学到了很多东西。也能快速学习调研一些技术问题并做了很多分享，不过大都写在了内部 ATA 上了，所以博客从此基本没怎么更新了，主要开始逛知乎回答一些相关问题。</p>\n<p>拥抱了变化，知道了老板视角。也初步认识商业的残酷，也大概知道淘宝的业务流程，对业务有一定的关注。从各种高层、大神的分享中也学到了很多。</p>\n<p>收获也颇丰，拿到了不错的绩效。</p>\n<p>此外，2015 年还有一个关于雾霾的纪录片发布出来。我也是第一次接触到了雾霾，我嗓子一直周期性的咽炎难受，原来发现可能是跟雾霾有关。之后，我的浏览器收藏夹多了一个“移民”目录。</p>\n<hr>\n<p>以上就是我在淘宝第一年的经历和学到的东西。下周将会发布第二年的经验，欢迎关注<a target=\"_blank\" href=\"https://juejin.im/user/5af141466fb9a07abf7276cb/activities\" rel>我的掘金</a>账号。</p>\n<p>平时在知乎比较活跃，也可以关注知乎账号 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.zhihu.com%2Fpeople%2Fyujiangshui\" rel=\"nofollow noopener noreferrer\">于江水</a> 和专栏 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fyujiangshui\" rel=\"nofollow noopener noreferrer\">于江水在知乎</a>，以便及时接到通知。也可以加我微信：Jiangshui-Yu。</p>\n', 'https://juejin.im/post/5c74d4b9e51d4512c37ea03b');
INSERT INTO `articles` VALUES ('5c75d34851882564965edb23', '我如何零基础转行成为一个自信的前端', '<blockquote>\n<p>这篇文章去年10月8号发过，后来因为一些 drama 删掉了。这次重发，是因为我想把这篇文章发到<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F57786471\" rel=\"nofollow noopener noreferrer\">知乎</a>，在我发到知乎之前，还是先发回掘金。我对掘金很有感情的。仅为此，不是为了炒冷饭，不求赞，不求关注。</p>\n</blockquote>\n<p>这个大言不惭的标题源自我与我所认识的前端从业者的比较，也源自别人的评价。读者也可以看我其它文章，评估我的专业能力。当然我不是在每个领域都能匹配别人三年的实践经验（原标题是学前端一年学三年的知识，后来觉得不妥就改了）。我还有很多技术栈没掌握，比如没写过小程序，没用过 jQuery（这个也不想再学了，只是依然还有用人单位在要求）。也有很多坑没踩过，比如没有做过浏览器兼容（说实话也不太想兼容 IE，浪费生命）。我想说的是我对 JS 这门语言以及 CS 这门学科掌握的深度，前端生态圈理解和熟悉的程度，以及知识迁移能力。</p>\n<p>我不是想炫耀自己多牛，而是想帮助和我有相似背景的人。我在掘金发了几篇文章后，有几个朋友在知道我零基础学编程一年半就进步这么快后，想知道我是怎么学的。这篇文章就是对他们的详细回答。</p>\n<h2 class=\"heading\" data-id=\"heading-0\">一，背景介绍</h2>\n<p>我本科学的是国际贸易，乱选的专业。毕业后做了半年外贸，实在不喜欢，然后去做英文编辑了。第二份工作也很无聊，就是写英文软文，发表在国外的行业期刊上，给公司做广告。然后也做英文官网的内容。这是一个很没创意的工作。每天写几篇我自己都没感觉的文章，不知道价值在哪。最重要的是，这份职业里我找不到持续精进的方向，做一年和做三年好像区别不大。</p>\n<p>后来学前端也是误打误撞。因为我同时在做英文官网的内容和产品，会和前端打交道。当时公司的前端是学 UI 转过来的，我观察他的工作，以为就是 HTML 写个页面结构，然后 CSS 做个样式，然后用 JS 做点效果就可以了。这个简单啊，我也可以做。然后我就裸辞去学习前端开发了…… 后来发现我错了，但是自己跳的坑，流着泪也要爬出来。接下来我经历了人生中最难熬的一段时间，也经历了人生中第一次大的转变。</p>\n<p>我从 2017 年年初开始高强度学习，去年十一假期之后开始我的第一份前端工作，到今天刚好工作一年时间。接下来我将我的学习路径，学习方法，和学习资源整理分享出来，希望可以帮到更多人。</p>\n<h2 class=\"heading\" data-id=\"heading-1\">二，准备工作</h2>\n<p>学习不只是找到好的学习路径，掌握好的学习方法就可以了的，要成为优秀的学习者，是要求很多素质和习惯的。我长期以来都是一个懒散的人，三分钟热度，自律很差。我相信大部分人都这样。在意识到学习任务的艰巨后，我想的是我不能再放弃了，我觉得我年轻试错的阶段已经过了，经不起再失败了，于是我专门花了很长时间来调整自己的习惯和行为。这里我分享一些对我帮助最大的资源：</p>\n<h3 class=\"heading\" data-id=\"heading-2\">1. 一本书</h3>\n<p>《习惯的力量》（<em>The Power of Habit</em>）。这本书让我意识到自己的坏习惯是需要科学的方法来改变的，一味地自责和焦虑是没用的。习惯的改变靠的不是主观意志力，而是 cue （不知道怎么翻译，刺激物？）和日常流程（routine）来维持的，所以我把学习场所从家换到了星巴克。而 cue 分为情绪，时间，场所，上一个行为等，这些都需要自己去定位查找。找到触发你的坏习惯的 cue，改变它。另外，每天都要有计划，计划会触发奖赏期待，让你更不容易回到坏习惯。最重要的是，关键好习惯的养成，会让你养成其它好习惯更容易。比如早起的习惯一旦养成，我又养成了早上学习最具挑战知识的习惯。</p>\n<h3 class=\"heading\" data-id=\"heading-3\">2. 一门课程</h3>\n<p>Coursera 上有一门课叫 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.coursera.org%2Flearn%2Flearning-how-to-learn\" rel=\"nofollow noopener noreferrer\">Learning How To Learn</a>, 目前是世界上参与人数最多的一门 MOOC 课程。这门课免费。讲师 Dr. Barbara Oakley 是奥克兰大学的工程学教授。她本来是学斯拉夫语言文学的，一直畏惧工科，数理学科成绩也很差，直到快 30 岁时，她才决定挑战自己去学工程学。听她讲学习过程是最有说服力的。另一位讲师 Dr. Terrence Sejnowski 是顶尖的神经科学专家。他会从脑科学和神经科学的实证角度告诉你为什么应该怎样学。下面讲下我对这门课程的一些理念的应用。</p>\n<p><strong>一，大脑的发散和集中工作模式</strong></p>\n<p>发散模式（diffuse mode）指的是注意力从工作对象处转移开来，放松下来，让灵感有机会出现。集中模式（focused mode）自然是指全部注意力放在工作对象上，高强度思考。学习时，我采用番茄工作法，每工作 25 分钟休息 5 分钟。然后每工作 2 到 3 个小时，出门散下步，或者在家时耍下壶铃。这个习惯养成后，很多神奇的事情会发生。比如有一次我在写 Rxjs 应用时，卡在一个地方，怎么也想不出来解决方案，然后去洗了个澡，灵感就来了，换几个操作符的组合就解决了。还有数不清有多少次在梦里想出一个解决方案，起床就去试，结果真的行的通。</p>\n<p><strong>二，多运动</strong></p>\n<p>Dr. Terrence Sejnowski 讲解了为什么运动会促发大脑新的神经元的生长。高强度的脑力活动，你需要大脑保持最佳机能。我在开始学习之前就是个健身狂魔（见下图），每周有至少四天要去健身房。找到工作前的学习期，我也保持着这个频率锻炼。工作后，没时间再去健身房了，我就买了个 Concept 2 划船机，早上在家锻炼。锻炼推荐 HIIT （高强度间歇训练）方法，燃脂迅速，最短时间内达到锻炼效果。</p>\n<p></p><figure><img alt=\"deadlift\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/10/7/1664d5286631856c?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"1278\"><figcaption></figcaption></figure><p></p>\n<p><em>硬拉训练</em></p>\n<p><strong>三，刻意训练</strong></p>\n<p>学生时代我经常忽略做题训练，看懂了答案就以为自己掌握了。但其实懂答案和自己写出来是两回事。学习者很容易产生能力幻觉（Illusion of Competence），看懂了知识点，就以为自己掌握了。只有自己能独立解释清楚的，才算是自己掌握的。自己在网上找些小挑战做（比如 100 days of code, 还有 JavaScript 30），多在 codewars 和 LeetCode 上刷题（我主要是在 codewars 上做题），可以巩固刚学的知识。</p>\n<p><strong>四，间隔重复</strong></p>\n<p>一天花 6 个小时学一个主题，和用 6 天时间，一天花 1 小时来学习同一个主题相比，肯定是后者掌握的更好。当然重复不是简单的重读一遍。而是刻意回忆，测试自己还能不能想起来。大家可以试试 Studies 这个软件，创建和管理知识卡片，方便复习。iOS 和 Mac 上都有。</p>\n<p>还有很多，我就不全列了。强烈建议大家去学一遍课程，自己摸索出适合自己的方法。中文版在<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.coursera.org%2Flearn%2Fruhe-xuexi\" rel=\"nofollow noopener noreferrer\">这里</a></p>\n<h3 class=\"heading\" data-id=\"heading-4\">一个习惯</h3>\n<p>早起。每天早上 4 点准时起床。我知道这个听起来挺疯狂，但我坚持了一年半了。（也有例外，但最晚大多数时候不超过 5 点，极个别例外比如加班，也不会超过 6 点）。我以前的习惯是经常晚上玩手机到凌晨 2 点睡，还骗自己，以为自己是夜猫子型。转变习惯用了一个月。下面是一些技巧。1. 吃补剂。我吃的是 Swiss Sleep，一种澳洲的草本保健品。我知道很多专家说保健品不靠谱，但我吃了这个真的睡的更香了，用 Sleep Cycle 监测到的深度睡眠增加了。2. 下午 2 点之后不喝咖啡，晚上 8 点之后不看电子屏幕。（这是我脱产学习时候的状态。后来进阿里后我用的折中办法是电脑装 flux，屏幕看着就昏昏欲睡）3. 睡前深呼吸，放慢呼吸频率。四，我用 Yeelight 床头灯，早上定时模拟日出。自然醒的感觉，不会像闹钟那样讨厌。早起后，早上至少有 3 个小时不会有人打扰你（我做的更极端，直接把微信卸载了，全天都没人打扰）。而晚上睡的早，也不会漫无目的地玩手机聊天。从早上起床到中午 12 点，我可以完成 10 个番茄闹钟。中途还有充足的休息时间。</p>\n<h3 class=\"heading\" data-id=\"heading-5\">一个 APP</h3>\n<p>Headspace 是国外一个比较流行的冥想软件。可能很多人对冥想的感觉就是太玄学，但它真的作用很大。对于我而言，主要是两个作用，一个是集中注意力，另外一个是克服焦虑。一个人没有其他帮助，学习一个全新的领域，也不知道能不能成功，压力还是很大的。而这种压力可能并不一定会转化为动力，而是会积累着，成为拖累。冥想可以让我暂时远离这些担忧，调整注意力。Headspace 的指导语速很慢，听懂比较容易。</p>\n<h2 class=\"heading\" data-id=\"heading-6\">三，学习资源</h2>\n<p>前面的准备工作做好后，开始进入正题了。这部分我分享下对我帮助最大的一些学习资源。</p>\n<h3 class=\"heading\" data-id=\"heading-7\">1. Frontend Masters</h3>\n<p>正如 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Ffrontendmasters.com%2F\" rel=\"nofollow noopener noreferrer\">Frontend Masters</a> 这个网站名字所说明的，能在这里讲课的，都是大师级别。我挑几门对我帮助最大的课程，并简短说明如下：</p>\n<ol>\n<li>\n<p><strong>The Good Parts of JavaScript and the Web</strong></p>\n<p>老师是 Douglas Crockford，JS 教父级人物，《JavaScript 语言精髓》作者。这门课讲了 JS 的历史和一些重要的语言细节，并把重点放在函数上。Crockford 认为函数这是 JS 这门语言最重要的部分。后半部分讲了浏览器和服务器的工作原理，以及网络安全。</p>\n</li>\n<li>\n<p><strong>(1) Deep JavaScript Foundations (2) Rethinking Asynchronous JavaScript (3) Functional-Light JavaScript, v2 (4) ES6: The Right Parts (5) Organizing JavaScript Functionality (6) Coercion in JavaScript</strong></p>\n<p>共 6 门课，老师都是 Kyle Simpson.《你不知道的 JS 》系列书作者，等下还会提到他。第一门课深入了 JS 的大部分重要细节，这是学好 JS 的第一步。其它几门课分专题继续深入，分别是异步编程，ES6 的重要部分，组织 JS 功能模块（学了这个后，我从没写过面条代码），轻量级函数式编程（有配套书，个人觉得是 JS 开发必学），最后是 JS 中的强制类型转换。</p>\n</li>\n<li>\n<p><strong>(1) Webpack 4 Fundamentals (2) Web Performance with Webpack (3) Webpack Plugins System</strong></p>\n<p>共 3 门关于 Webpack 的课程，老师都是 Sean Larkin。微软 Edge 团队的 Technical Program Manager，Webpack 和 Angular 核心团队成员，前不久刚来中国参加过前端圈的大会。这几门课从基础开始，一直到进阶，呈现了 Webpack 的基本原理，操作技巧，以及插件生态。</p>\n</li>\n<li>\n<p><strong>Hardcore Functional Programming in JavaScript</strong></p>\n<p>老师是 Brian Lonsdorf，学函数式编程的话，不知道他会多很多挣扎。等下还会提到他。课程从基本的函数组合开始，逐渐讲到硬核函数式编程（Functors, Applicatives 和 Monads 的应用等）</p>\n</li>\n<li>\n<p><strong>(1) Asynchronous Programming in JavaScript (with Rx.js Observables) (2) Advanced Asynchronous JavaScript</strong></p>\n<p>共两门课。老师是 Jafar Husain。Netflix UI 工程团队 leader，响应式编程专家，TC39 成员。第一门课从零开始写常用的 Rxjs 操作符，逐渐进阶到 DOM 事件流处理，网络请求的处理等。第二门课是进阶课，从零开始写个 Observable，然后用 Observable 来解决一些棘手的动画问题。最后会用课程知识写个应用。</p>\n</li>\n<li>\n<p><strong>Advanced Vue.js Features from the Ground Up</strong></p>\n<p>老师是尤雨溪，这位不用我介绍了吧。这门课里面，尤雨溪会教你从零开始实现 Vue 的核心构成，如响应式系统，插件，渲染函数，路由，状态管理等。在我入职我目前所在公司的时候，我还没写过 Vue，入职后第一周学了这门课，然后带着团队重构 Vue 项目了。</p>\n</li>\n</ol>\n<p>还有很多优秀课程，全部列出来篇幅太大了。建议大家去探索寻宝。另外 Frontend Masters 是订阅制，费用比较贵，按月付的话，接近 40 美元一个月，年付会便宜很多。黑五和开学季会有折扣。我是在开学季用折扣价订了一年。</p>\n<p>另外，Frontend Masters 每年都会出一个免费的前端学习手册。今年的<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Ffrontendmasters.com%2Fbooks%2Ffront-end-handbook%2F2018%2F2018.html\" rel=\"nofollow noopener noreferrer\">点击这里</a>。</p>\n<h3 class=\"heading\" data-id=\"heading-8\">2. Egghead</h3>\n<p>这个网站的风格是简短精炼。每个视频都很短，语速很快，适合有一定基础，想用碎片时间充电的前端从业人员。很多库的作者会在这里讲他们的作品，比如 Dan Abramov 会在这里讲 Redux，Michel Weststrate 会在这里讲 Mobx 和 Mobx State Tree 等，这些都是免费的。付费课程质量也大部分很高。你想学的某些主流技术，热门的库，大部分都在这里找得到教程。比如 Ramda，它有 200 多个 API，而且与其它库风格迥异，我是怎么短时间内对这么多 API 应用自如的？除了大量地训练和挤地铁时间查看文档，还离不开 Egghead 上的实战课程。这里再挑几门对我帮助最大的部分课程。剩下一些课程我会在本文后面再提。</p>\n<ol>\n<li>\n<p><strong>(1) RxJS Beyond the Basics: Creating Observables from scratch (2) RxJS Subjects and Multicasting Operators (3) Save time avoiding common mistakes using RxJS (4)Use Higher Order Observables in RxJS Effectively</strong></p>\n<p>全是 RxJS 的课程，老师是 André Staltz，我最崇拜的技术人之一，等下还会讲到他。这些课程从 RxJS 的入门一直讲到高阶操作。这些课程和前面提到的 Jafar Husain 的课程会有重合，但我觉得从不同的老师那里，从不同角度学习，可以掌握地更全。当然你不用每个主题都找两个老师学……我只是发现我订阅的两个网站都有 RxJS 课程，所以全学了。</p>\n</li>\n<li>\n<p><strong>Automate Daily Development Tasks with Bash</strong></p>\n<p>作为开发人员，你应该掌握一些自动化工作流，提升开发效率。这门课讲了开发中常用的 Bash 操作技巧，不管是前端和后端，都适用。</p>\n</li>\n<li>\n<p><strong>Quickly Transform Data with Transducers</strong></p>\n<p>我之前发表的消灭 for 循环的那篇文章，里面用的 Transduce 写法，就是在这门课里学到的。</p>\n</li>\n</ol>\n<p>Egghead 还有很多高阶 CSS 课程以及其它大前端的课程，比如单元测试，Serverless，等等。还有三门高阶函数式编程的课程，我放到后面部分讲。</p>\n<h3 class=\"heading\" data-id=\"heading-9\">3. Udemy</h3>\n<p>Udemy 是个在线教育界的淘宝，什么课程都有。你能在那里学音乐，学绘画，甚至还能学咏春拳…… 当然能学编程，而且有些热门编程老师确实很厉害。Udemy 有个套路，标价 200 美元的课程，经常悄悄打折 9.9 美元卖。我所有课程都是最低价买的，前后一年半共买了 60 多门课，通常是在黑五圣诞等折扣季买，当然，Udemy 几乎每个月都在促销。我买的课程覆盖前端后端，深度学习，区块链开发等。我只把前端课程的 2 / 3 学了，其它的真学不动了，大多数属于冲动消费……</p>\n<p></p><figure><img alt=\"screenshot\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/10/7/1664d528661268e0?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"1145\"><figcaption></figcaption></figure><p></p>\n<p><em>我学习的课程部分截图</em></p>\n<p>这部分我就不详细介绍课程了，只推荐三个老师。</p>\n<p>一是 Stephen Grider，我买了他大部分课程。Stephen 擅长用很直观的图表来拆解工程概念，再难的东西他也能拆到用日常语言解释。我一开始自学算法时，感到很吃力。Stephen 的算法课让我通过 JS 掌握了基础的计算机算法。他还有 Node，React，MongoDB 以及 GraphQL 的课程，大部分涵盖了入门和进阶。</p>\n<p>第二个是 Andrew Mead。他讲课能力也很优秀，我第一次学 Node 是学的他的课程，收获很大。另外他对学员的问题回应非常及时和详细。他的课程和 Stephen 的重复率挺高，不用两个都买。</p>\n<p>如果有兴趣学 iOS 开发，强烈推荐 Angela Yu 的课。（我做了半年 React Native 开发，所以去学了原生开发。）Angela 讲课幽默可爱，新人友好。她似乎是中国长大的，在英国学医。本来是医生，后来转行做 iOS 开发和设计了。厉害的人生各有各的不同啊……</p>\n<h3 class=\"heading\" data-id=\"heading-10\">4. <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwesbos.com%2F\" rel=\"nofollow noopener noreferrer\">Wes Bos</a></h3>\n<p>Wes Bos 可能相当于北美阮一峰…… 当然这种类比是不恰当的。我的意思是，他的课程覆盖了前端很广领域，也广受欢迎。如果你入门没多久，可以学他的免费课程 JavaScript 30. 用一个月时间，每天用原生 JS 写个网页应用。Mozilla 还赞助他开了 CSS Grid 的课程，吸引开发者用 FireFox。你也可以免费学这门课。他还有付费的 Node 和 React 课程。最近他准备出一个高阶 React 和 GraphQL 课程，我观望中，可能会买。另外他还主持了一个播客节目叫 Syntax，主题是前端开发，我每期都会听。挤地铁时用两倍语速听，能吸收到很多新鲜知识。</p>\n<h3 class=\"heading\" data-id=\"heading-11\">5. YouTube</h3>\n<p>YouTube 是个很神奇的地方，每个知识和娱乐的领域都能在这里找到精华。我在这里列出几个前端和泛编程的频道。</p>\n<ol>\n<li>\n<p><strong>Fun Fun Function</strong></p>\n<p>主播名字太长了，粉丝都叫他 MPJ。MPJ 是瑞典人，之前一直在 Spotify 工作，最近辞职后全职做 Fun Fun Forum 论坛了。这个频道覆盖了很杂的 JS 和前端开发知识。我在这个频道学到的都是在其它地方学过的，比如函数式编程，设计模式等，但是在这里学更像一种放松和实时看高手是怎样写代码和解决问题的。</p>\n</li>\n<li>\n<p><strong>Traversy Media</strong></p>\n<p>主播非常勤奋，更新很频繁。内容大多是初级和中级，非常适合新人学习。我现在偶尔也会看他新出的教程，用原生 JS 写个动效，用 CSS 写完成度 100% 的企业展示页面等。</p>\n</li>\n<li>\n<p><strong>Coding Tech</strong></p>\n<p>这个频道会持续更新计算机行业最新的优质演讲。前端和其它领域都有。</p>\n</li>\n</ol>\n<h3 class=\"heading\" data-id=\"heading-12\">6. GitHub</h3>\n<p>GitHub 上参考别人的代码，能加快自己的理解。比如，Jason Miller（等下我还会介绍他） 的热门 repo 我每个都会看。EventEmitter，状态管理，异步函数自动放到 web worker 的工具库，Fetch API polyfill，等等听起来挺复杂的东西，他五六行，十几行代码就实现了，还发布到 NPM 成为完整的包。还有 You Don&apos;t Need jQuery, You Don&apos;t Need Lodash, 30 Seconds of Code 等 Repo，对提升原生 JS 解决问题的能力有非常大的帮助。碎片时间可以在手机上学习。</p>\n<h3 class=\"heading\" data-id=\"heading-13\">7. JavaScript Weekly</h3>\n<p>我觉得 JavaScript Weekly（免费 Newsletter） 是前端开发者必须订阅的，但我发现好像身边人都不知道。很少有人能不关心技术趋势还能走在前面的。你应该关注同行最近又开发出了什么酷的东西，你关注的技术又出了哪些新教程。不过，每天盯着技术热点看也容易分心。一周关注一次，频率刚刚好。</p>\n<h2 class=\"heading\" data-id=\"heading-14\">四，影响我的技术人</h2>\n<p>如果你了解过一万小时天才理论，你可能知道一个好的 Mentor 在个人成长中的无法替代的作用。大多数人都没有如此幸运，找到一个好的导师。我也是。对此我的一个并不完美的替代方案是关注行业里的思考者和先行者，听下他们的建议，了解他们是怎样思考和工作的。下面是对我影响最大的技术人：</p>\n<ol>\n<li>\n<p>Kyle Simpson. 我的 JS 是他领入门的，也是他带着走向进阶的。我的整个学习路径，都有他的影响。作为一个教育者，他会给学习者很多各方面的建议。我会关注他所有的演讲和开源项目。Twitter: @getify</p>\n</li>\n<li>\n<p>Eric Elliott. 我学函数式编程是始于他。我比较幸运，一开始学编程的时候刚好碰到 Eric 开始在 Medium 上连载函数式编程教程。我在学了三个月 JS 之后，就遇到了一个全新的编程范式，并且被说服了。我推荐所有 JS 开发者都了解下这一系列文章 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmedium.com%2Fjavascript-scene%2Fcomposing-software-an-introduction-27b72500d6ea\" rel=\"nofollow noopener noreferrer\">Composing Software</a> 你可以听一个从 BASIC 时代就开始写程序的前辈，是怎样看待不同编程范式的；了解为什么组合比继承更优，为什么 JS 适合用来函数式编程。Twitter: _ericelliott</p>\n</li>\n<li>\n<p>André Staltz. 他是社区里面的响应式编程专家。如果你想学响应式编程的话，一定要看他写的这篇文章，<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgist.github.com%2Fstaltz%2F868e7e9bc2a7b8c1f754\" rel=\"nofollow noopener noreferrer\">The introduction to Reactive Programming you&apos;ve been missing</a>. 他还写了一个函数响应式框架叫 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fcycle.js.org%2F\" rel=\"nofollow noopener noreferrer\">Cycle.js</a> 除了技术，他最让我佩服的还有他对技术与社会之间关系的思考。他对于目前 Facebook 和 Google 等互联网巨头控制用户数据的现状不满，他的一个 mission 就是要创造去中心化的互联网。（万维网的创始人，Tim Berners-Lee 爵士，也在做这件事）他最近发布了一款安卓手机应用叫 Manyverse，一个真正去中心化社交平台。这款应用是用 React Native 写的，开源。感兴趣的话，你可以看下源码，看下他是怎么组织代码的。Twitter: @andrestaltz</p>\n</li>\n<li>\n<p>Sarah Drasner. Sarah 是个非常 nice 的姐姐，非常有亲和力。她是 SVG 动画专家，CSS 专家，微软资深开发。还是 Vue 核心团队成员。她在 Frontend Masters 上有 Vue.js，高阶 SVG 动画，UI 设计等课程。她在 Twitter 上也会发很多开发 Tips。Twitter: @sarah_edo</p>\n</li>\n<li>\n<p>Wes Bos. 刚刚提到过这位。他除了在播客上给开发者提供很多建议外，还在 Twitter 上分享很多开发技巧，JS, CSS, Bash, VSCode 等技巧都有。我在开发中也用了很多他分享的技巧，省了很多时间。Twitter: @wesbos</p>\n</li>\n<li>\n<p>Mathias Bynens. 谷歌 V8 引擎工程师，TC39 成员。他会从引擎实现的角度，告诉开发者怎么写代码。他也会分享一些 V8 的项目细节等。我之前写了消灭 for 循环的文章，好多人反对，还有些人直接嘲讽我。其中有一个说法是高阶函数没有 for 循环性能好。作为一个新手，我哪来勇气去对杠来自资深开发者的质疑的？因为引擎开发者都说了，那点微观语言层面的性能差异，不会成为你整个应用的性能瓶颈。你应该把注意力放在编写易理解和易维护的代码上。 Twitter: @mathias</p>\n</li>\n<li>\n<p>Brian Lonsdorf. 网名 Dr. Boolean. 这家伙就是个天才。他有些害羞，但是在讲他最擅长的函数式编程的时候，总能把满脑子天马行空的想法讲地很清楚。如果想学硬核函数式编程的话，推荐从关注他开始。他 Twitter 更新不频繁，但是更新的时候一般都是值得你记笔记的时候。Twitter: @drboolean</p>\n</li>\n<li>\n<p>Jason Miller. 刚有提到他。他是 Google Chrome 团队工程师，还是 Preact 的作者。他写了一堆平均只有十几行代码的库。研究他的代码不用一个文件一个文件地跳，因为就在一个文件里…… 他在 Twitter 上也很活跃。Twitter: @_developit</p>\n</li>\n<li>\n<p>Bartosz Milewski. 这位真是位大神。我说我被他影响都有强行给自己贴金的嫌疑。他有量子物理博士学位，后来去做软件开发了，成了 C++ 专家，出过 C++ 的专著。后来因受不了 C++ 糟糕的设计，去写 Haskell 了，也成了专家。最近又把兴趣转向范畴论了，开始给程序员教范畴论。业余还研究音乐理论（我看他 YouTube 点赞列表知道的……）。我最近几个月每周都安排几个早晨，去他的 YouTube 频道听他讲范畴论（这个不需要高数基础）。等下我会继续谈他的范畴论教程。Twitter: @BartoszMilewski</p>\n</li>\n</ol>\n<p></p><figure><img alt=\"5bb8a75d2b248\" class=\"lazyload\" data-src=\"https://user-gold-cdn.xitu.io/2018/10/7/1664d528662c6358?imageView2/0/w/1280/h/960/ignore-error/1\" data-width=\"1280\" data-height=\"960\"><figcaption></figcaption></figure><p></p>\n<p><em>在听 Bartosz Milewski 讲范畴论</em></p>\n<h2 class=\"heading\" data-id=\"heading-15\">五，函数式编程学习路线图</h2>\n<p>如果你是新人，不要被这部分内容吓到了。这只是我的个人技术偏好。你不用懂抽象代数和范畴论也可以走很远，不过，轻量级的函数式编程，比如高阶函数，函数组合，闭包，柯里化，偏函数应用，递归，memoization，惰性求值等等，是必须要掌握的。我之所以把这部分加进来，除了有人问我函数式编程学习资料之外，还因为对函数式编程的兴趣是推动我持续学习的强大动力。我从一个高数一半课程挂科的文科生，到现在成为一个可以理解 lambda 演算和邱齐编码（Church Encoding）的程序员，这对于我是很有智力成就感的。这种成就感是以前从没体会过的。</p>\n<p>我建议大家都找到驱动自己成长的兴趣点，不一定要和我一样。你可以选择数据可视化，高阶动画，UI/UX 设计（同时懂代码和设计会让你拥有独特的竞争力）等等。对后面两个部分感兴趣的可以关注 Sarah Drasner 和 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Ftympanus.net%2Fcodrops%2Fauthor%2Fcrnacura%2F\" rel=\"nofollow noopener noreferrer\">Mary Lou</a> 的作品。</p>\n<p><strong>系统教程</strong></p>\n<ol>\n<li>\n<p><em><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fgetify%2FFunctional-Light-JS\" rel=\"nofollow noopener noreferrer\">Functional-Light JavaScript</a></em> ，Kyle Simpson 的作品，刚刚有提到。这本书和 Eric Elliott 的 <em>Composing Software</em> 是入门 JS 函数式编程的最佳教程。这两个教程所教的知识，能让你轻松应付工作中对于函数式编程的实际需求。一般情况下，你的项目中所允许出现的函数式代码，也只能在这个范围内了，再硬核一点别人维护起来就困难了。</p>\n</li>\n<li>\n<p><em><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fmostly-adequate.gitbooks.io%2Fmostly-adequate-guide%2F\" rel=\"nofollow noopener noreferrer\">Professor Frisby&apos;s Mostly Adequate Guide to Functional Programming</a></em> 作者是 Brian Lonsdorf。他写代码时是 Dr. Boolean, 写书时是 Professor Frisby... 学完这本书，你可以掌握函数式编程应用 90% 以上知识。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fegghead.io%2Fcourses%2Fprofessor-frisby-introduces-composable-functional-javascript\" rel=\"nofollow noopener noreferrer\">Professor Frisby Introduces Composable Functional JavaScript</a> 作者还是 Brian。Egghead 上的课程。虽然课程内容和上面那本书重复了，但还是值得看一下。Brian 用动画方式讲课，有些呆萌。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Flearnyouahaskell.com%2F\" rel=\"nofollow noopener noreferrer\">Learn You A Haskell for Great Good</a> 学 Haskell 最佳资源之一。这个教程不同于其它教程之处在于它语言幽默风趣，会让你读着读着笑出来。教程默认读者没有函数式编程训练，所以对新人来说学习难度曲线平缓些。</p>\n</li>\n<li>\n<p><em><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fhmemcpy%2Fmilewski-ctfp-pdf\" rel=\"nofollow noopener noreferrer\">Category Theory for Programmers</a></em> Bartosz Milewski 的范畴论教程。<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DI8LbkfSSR58%26amp%3Blist%3DPLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_\" rel=\"nofollow noopener noreferrer\">视频教程地址</a>。这一系列教程是面向程序员的，所以不用太担心一开始就听不懂，难以入门。不过，后期要学懂还是要花点精力多去找些材料读的，毕竟范畴论是种高度抽象的知识。教程涉及到代码的部分会用 C++ 和 Haskell，读者最好懂点 C++。</p>\n</li>\n</ol>\n<p><strong>其它值得学习的</strong></p>\n<ol>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fjrsinclair.com%2Farticles%2F2018%2Fhow-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript%2F\" rel=\"nofollow noopener noreferrer\">How to Deal with Dirty Side Effects in Your Pure Functional JavaScript</a> 这篇文章是最近 JavaScript Weekly 推的。在我弄懂了一些 FP 概念之后，再回头看这篇入门文章，也收获了很多，更清楚了 FP 的每一步为什么要那样做。一个应用的实际意义就是要产生作用 (effects)，例如从服务器请求到内容然后展示到浏览器上等，全是 effects，但是函数式编程不允许副作用 (side effects)，即在计算过程中不许产生作用，那还怎么写程序？这篇文章一步一步尝试解决如何消除程序中的副作用，只在计算全部完成再释放作用。此文不会扔概念，而是用普通代码来解决问题，一步步地，你在不知不觉中就懂了 Functors, Applicative Functors 和 Monads。只要你懂普通 JS 你就能懂本文代码。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DJZSoPZUoR58\" rel=\"nofollow noopener noreferrer\">A Million Ways To Fold</a> Brian Lonsdorf 的演讲。在我发表《如何在 JS 代码中消灭 for 循环》的时候，反对的观点之一是，我所展示的写法不是很灵活，一个新需求下来，让我乖乖改回 for 循环。我理解一些开发者忙于实际开发，学一些太基础的东西似乎对开发没什么用处，所以不去学习积累。在这个例子里，我明白了不懂 CS 基础是会限制想象力的。在这个演讲里，Brian 介绍了范畴论里面的 F-algebra 和 catamorphism。没见过这些术语没关系，只用知道，理解了这个演讲，你就能明白，<strong>能用 for 循环表达的计算，全部能用 reduce 函数表达</strong>。还会有人说，reduce 底层也是用 for 循环实现的！<strong>这就好像我告诉你盖房子要用砖头而不要直接用沙子，你告诉我砖头是用沙子制成的</strong>。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fegghead.io%2Fcourses%2Fstate-monad-in-javascript\" rel=\"nofollow noopener noreferrer\">State Monad in JavaScript</a> 在用纯函数写应用时，处理状态是件很麻烦的事。State 是函数式编程中专用来解决状态管理的一个代数数据类型（Algebraic Data Type）。这门课会用一个叫 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fcrocks\" rel=\"nofollow noopener noreferrer\">crocks</a> 的库，学了这门课程你可以继续自己探索 crocks 的其它数据类型和工具函数。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fegghead.io%2Fcourses%2Fsafer-javascript-with-the-maybe-type\" rel=\"nofollow noopener noreferrer\">Safer JavaScript with the Maybe Type</a> 函数式编程不会用 if else 来做空值处理，取而代之的是 Maybe 数据类型。Maybe 让你在组合函数时不用担心空值处理。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fraganwald.com%2F2015%2F02%2F13%2Ffunctional-quantum-electrodynamics.html\" rel=\"nofollow noopener noreferrer\">The Quantum Electrodynamics of Functional JavaScript</a> 读懂这篇文章，你就明白了 Combinatory Logic (组合子逻辑) 和 Church Encoding (邱齐编码)。这篇文章只介绍了原理，有人根据这篇文章，写了两个库： <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbenji6%2Fchurch\" rel=\"nofollow noopener noreferrer\">church</a>，用 JS 实现邱齐编码。<a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fbenji6%2Fcombinators-js\" rel=\"nofollow noopener noreferrer\">combinators-js</a>，用 JS 实现所有的 Combinator（组合子）。懂这些东西对你实际写代码并没有帮助，就好像懂量子物理对建造桥梁也没什么用处。</p>\n</li>\n<li>\n<p><a target=\"_blank\" href=\"https://link.juejin.im?target=http%3A%2F%2Fraganwald.com%2F\" rel=\"nofollow noopener noreferrer\">Reginald Braithwaite 的博客</a> 上一篇文章也源自这个博客。本打算把我看过的全部列出来的，但实在有些繁琐了。大家可以自行翻阅。</p>\n</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-16\">六，犯过的错误</h2>\n<ol>\n<li>\n<p>尝试着一次学太多东西。不管你再怎么努力，人的时间和精力是有限的，一次能学的内容有限。我在找到开发工作之前的学习阶段，还学了 Python 和 Django，花了较长时间，效果也不好。工作后看到机器学习挺有意思，也花了一段时间学。我数学基础太差，就去 Khan Academy 学本科统计学和线性代数了。后来实在精力跟不上了，就搁置了。以后可能会再去挑战这个，但还是要一步一步来。</p>\n</li>\n<li>\n<p>浪费时间学当前阶段不适合学的东西。去年三月份学 Andrew Mead 的 Node 课程时，有一天收到他的邮件，说他新出了一个全栈课程，现在购买享受最低价。我一看简介，一个 JS 框架同时解决了前端后端和数据库，这个可以呀，学完我就能做全栈了。然后我就去花了一个月学 Meteor。那时候我 JS 基础还不是很好，学这种高阶的框架也只是记一堆 API，学完后一直没用过，到现在已经忘光了。</p>\n</li>\n<li>\n<p>不顾人才市场的需求，盲目学暂时用不到的技术栈。在找到开发工作前，我的学习期是比较长的，主要原因是我一直觉得自己学的还不够，好多东西还没掌握。但是我那个时候学的一些技术，并不是大多数用人单位所要求的，比如 Rx.js 和 GraphQL。虽然我并不后悔学了这两个技术，但我觉得我没必要在还没工作时就给自己那么大压力。我想很少有用人单位会要求一个没有工作经验的新人会写 Rx.js 和 GraphQL，再说国内用这两个技术的公司也很少。</p>\n</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-17\">七，接着学什么</h2>\n<ol>\n<li>\n<p>Haskell 和范畴论我还只学了冰山一角，接下来会继续学习。学 Haskell 只是在看教程，写代码很少，接下来试着用它写些简单应用。</p>\n</li>\n<li>\n<p>数据可视化。我一直断断续续在 Frontend Masters 上学 D3 课程，但是还没练过手。D3 也是 API 太多了，要掌握的话得多花点时间。</p>\n</li>\n<li>\n<p>CS 基础。今年四五月份时，我很认真想学一个在线 CS 学位，刚好我找到了 <a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fossu%2Fcomputer-science\" rel=\"nofollow noopener noreferrer\">OSSU</a>。但是我比较没耐心，我都通过 JS 学到比较高阶了，在基础课程里面还要用 Racket 学基础函数编写，我试着跳过一些课程，但是有些知识是依赖之前课程的，跳过了就听不懂了。后来我觉得进度实在太慢了就停下来了。但是 CS 基础我还是得学的，包括网络，算法，数据库，底层语言等。正如我发现的，不懂基础是会限制开发的想象力的。在合适的时机我会回去 OSSU 继续学，争取能学完课程。</p>\n</li>\n</ol>\n<h2 class=\"heading\" data-id=\"heading-18\">后记</h2>\n<p>基于我这一年多的学习和工作经验，我想给准备从事前端的朋友一些建议。</p>\n<p>首先是不要觉得前端比后端简单。我一开始是这样认为的，后来发现自己错了。前端要掌握的知识是很多的，前端工程复杂度也在提升。你可能经常听到前端圈有人说 “学不动了”，国外也有个现象叫 JavaScript fatigue. 你需要基础学很扎实，才能在技术飞速发展中不感到疲惫和迷失。我也不是劝你不要学前端，而是提醒你，做出决定前要有一个清楚的权衡考量。</p>\n<p>要有持续学习的准备。现在是学习者的最好的时代，你真的能在网上学到任何你想学的东西（高精尖核武器制作和火箭技术可能学不了……）。Google 和 Stack Overflow 上能找到你大部分问题的答案。找不到还可以问，问了别人也答不上来的话，那你已经学到很前沿了。本科学 CS 当然会让你起步更早，但是如果没有 CS 学位，现在开始也不会太晚。不远的将来，如果别人问我学历，除了真实学历，我还会很自信告诉对方，我的最高学历是 OSSU (Open Source Society University, 开源社会大学)。</p>\n<hr>\n<h2 class=\"heading\" data-id=\"heading-19\">第二次发表的后后记</h2>\n<p>上面的内容发表之后，很多公司找到了我，后来我去了蚂蚁金服。</p>\n<p>现在我做不到每天早上四点起床了。一般周二到周五六点到六点半起床，周六到周一可以四点到四点半起床。</p>\n<p>现在依然在学习，只是感到信息过载学不过来。以前经常看很多的资源，现在都不看了。甚至订阅了一年的 Frontend Masters 也有几个月没看了。不过我觉得我才起步，先学 CS 基础的。应用类的教程，跟着学就是无底洞，特别是前端。</p>\n<p>还是看到有很多新朋友在问怎么学英语。我之前写过：</p>\n<ul>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=%25E5%25A6%2582%25E4%25BD%2595%25E6%258A%258A%25E8%258B%25B1%25E8%25AF%25AD%25E5%25AD%25A6%25E5%2588%25B0%25E5%2585%25AD%25E7%25BA%25A7%25E6%25B0%25B4%25E5%25B9%25B3\" rel=\"nofollow noopener noreferrer\">如何把英语学到六级水平</a></li>\n<li><a target=\"_blank\" href=\"https://link.juejin.im?target=https%3A%2F%2Flambda.academy%2Fhow-to-achieve-english-fluency-as-native-speakers%2F\" rel=\"nofollow noopener noreferrer\">如何把英语学到母语水平</a></li>\n</ul>\n<p><strong>重点：</strong></p>\n<p>蚂蚁金服保险体验与社区技术组招高级前端开发工程师。我们开发了很有社会公益价值的相互宝，接下来会有更多激动人心的产品。有兴趣的同学联系我 <a target=\"_blank\" href=\"https://link.juejin.im?target=mailto%3Aray.hl%40alipay.com\" rel=\"nofollow noopener noreferrer\">ray.hl@alipay.com</a></p>\n', 'https://juejin.im/post/5c75d34851882564965edb23');

-- ----------------------------
-- Table structure for student
-- ----------------------------
DROP TABLE IF EXISTS `student`;
CREATE TABLE `student`  (
  `id` int(11) NOT NULL,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of student
-- ----------------------------
INSERT INTO `student` VALUES (1, '张三');
INSERT INTO `student` VALUES (2, '李四');

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `image` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `url` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT '',
  `subscribe` int(11) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  `article` int(11) UNSIGNED ZEROFILL NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 43 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES (44, '前端', 'https://lc-gold-cdn.xitu.io/bac28828a49181c34110.png', 'https://juejin.im/tag/%E5%89%8D%E7%AB%AF', 00000324659, 00000030090);
INSERT INTO `tags` VALUES (45, '后端', 'https://lc-gold-cdn.xitu.io/d83da9d012ddb7ae85f4.png', 'https://juejin.im/tag/%E5%90%8E%E7%AB%AF', 00000254666, 00000018770);
INSERT INTO `tags` VALUES (46, 'GitHub', 'https://lc-gold-cdn.xitu.io/0d614af263aa63aa6a77.png', 'https://juejin.im/tag/GitHub', 00000241936, 00000008064);
INSERT INTO `tags` VALUES (47, 'JavaScript', 'https://lc-gold-cdn.xitu.io/5d70fd6af940df373834.png', 'https://juejin.im/tag/JavaScript', 00000237947, 00000019762);
INSERT INTO `tags` VALUES (48, '架构', 'https://lc-gold-cdn.xitu.io/f27d811ad7e2b2a0bc24.png', 'https://juejin.im/tag/%E6%9E%B6%E6%9E%84', 00000206383, 00000006383);
INSERT INTO `tags` VALUES (49, '代码规范', 'https://lc-gold-cdn.xitu.io/cca10b4907aaca2788dd.png', 'https://juejin.im/tag/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83', 00000206001, 00000000406);
INSERT INTO `tags` VALUES (50, '面试', 'https://lc-gold-cdn.xitu.io/85dd1ce8008458ac220c.png', 'https://juejin.im/tag/%E9%9D%A2%E8%AF%95', 00000197261, 00000003890);
INSERT INTO `tags` VALUES (51, 'Android', 'https://lc-gold-cdn.xitu.io/7bab0e1e66ea386e6f94.png', 'https://juejin.im/tag/Android', 00000195207, 00000023129);
INSERT INTO `tags` VALUES (52, '算法', 'https://lc-gold-cdn.xitu.io/68a1097944c7fa1d7961.png', 'https://juejin.im/tag/%E7%AE%97%E6%B3%95', 00000190620, 00000008022);
INSERT INTO `tags` VALUES (53, '程序员', 'https://lc-gold-cdn.xitu.io/63baec1130bde0284e98.png', 'https://juejin.im/tag/%E7%A8%8B%E5%BA%8F%E5%91%98', 00000183306, 00000006667);
INSERT INTO `tags` VALUES (54, '设计', 'https://lc-gold-cdn.xitu.io/f2e3a6fceb1a4f1ce6b6.png', 'https://juejin.im/tag/%E8%AE%BE%E8%AE%A1', 00000180110, 00000005449);
INSERT INTO `tags` VALUES (55, 'CSS', 'https://lc-gold-cdn.xitu.io/66de0c4eb9d10130d5bf.png', 'https://juejin.im/tag/CSS', 00000179497, 00000005197);
INSERT INTO `tags` VALUES (56, 'Java', 'https://lc-gold-cdn.xitu.io/f8ee3cd45f949a546263.png', 'https://juejin.im/tag/Java', 00000169535, 00000019500);
INSERT INTO `tags` VALUES (57, '数据库', 'https://lc-gold-cdn.xitu.io/c57a5426c2a8ab565881.png', 'https://juejin.im/tag/%E6%95%B0%E6%8D%AE%E5%BA%93', 00000168723, 00000007254);
INSERT INTO `tags` VALUES (58, '设计模式', 'https://lc-gold-cdn.xitu.io/95e6729d56b35272b0d6.png', 'https://juejin.im/tag/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F', 00000168376, 00000002441);
INSERT INTO `tags` VALUES (59, 'Node.js', 'https://lc-gold-cdn.xitu.io/f16f548d25028a1fdd80.png', 'https://juejin.im/tag/Node.js', 00000165349, 00000005613);
INSERT INTO `tags` VALUES (60, '前端框架', 'https://lc-gold-cdn.xitu.io/f7a198f1e1aeb6d79878.png', 'https://juejin.im/tag/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6', 00000164796, 00000001353);
INSERT INTO `tags` VALUES (61, 'Vue.js', 'https://lc-gold-cdn.xitu.io/7b5c3eb591b671749fee.png', 'https://juejin.im/tag/Vue.js', 00000162377, 00000006320);
INSERT INTO `tags` VALUES (62, 'HTML', 'https://lc-gold-cdn.xitu.io/f18965b2a0ef9cac862e.png', 'https://juejin.im/tag/HTML', 00000160947, 00000002016);
INSERT INTO `tags` VALUES (63, '产品', 'https://lc-gold-cdn.xitu.io/e98ecc945167940d7b6a.png', 'https://juejin.im/tag/%E4%BA%A7%E5%93%81', 00000158244, 00000010606);
INSERT INTO `tags` VALUES (64, '开源', 'https://lc-gold-cdn.xitu.io/553ecacd498946a9a6d9.png', 'https://juejin.im/tag/%E5%BC%80%E6%BA%90', 00000155456, 00000004233);
INSERT INTO `tags` VALUES (65, 'Linux', 'https://lc-gold-cdn.xitu.io/b49dc843907aa7843a77.png', 'https://juejin.im/tag/Linux', 00000143405, 00000002728);
INSERT INTO `tags` VALUES (66, 'Git', 'https://lc-gold-cdn.xitu.io/3cf1219be35e6fa28229.png', 'https://juejin.im/tag/Git', 00000139495, 00000001460);
INSERT INTO `tags` VALUES (67, 'iOS', 'https://user-gold-cdn.xitu.io/1532428449837649233abd9e9cfa8c4104f0ca4210f05.jpg', 'https://juejin.im/tag/iOS', 00000135657, 00000012815);
INSERT INTO `tags` VALUES (68, 'React.js', 'https://lc-gold-cdn.xitu.io/f655215074250f10f8d4.png', 'https://juejin.im/tag/React.js', 00000134717, 00000006265);
INSERT INTO `tags` VALUES (69, 'Python', 'https://lc-gold-cdn.xitu.io/b51a1dacf9bb7883defe.png', 'https://juejin.im/tag/Python', 00000134063, 00000007643);
INSERT INTO `tags` VALUES (70, '微信', 'https://lc-gold-cdn.xitu.io/ceeddfb49045193160bf.png', 'https://juejin.im/tag/%E5%BE%AE%E4%BF%A1', 00000128435, 00000007862);
INSERT INTO `tags` VALUES (71, '全栈', 'https://lc-gold-cdn.xitu.io/993d9815412ebf9bc888.png', 'https://juejin.im/tag/%E5%85%A8%E6%A0%88', 00000125070, 00000000368);
INSERT INTO `tags` VALUES (72, 'ECMAScript 6', 'https://lc-gold-cdn.xitu.io/e384dbc6d1ab15f046cf.png', 'https://juejin.im/tag/ECMAScript%206', 00000121266, 00000001079);
INSERT INTO `tags` VALUES (73, 'Google', 'https://lc-gold-cdn.xitu.io/dfaa9adfc35ab7476040.png', 'https://juejin.im/tag/Google', 00000118090, 00000004471);
INSERT INTO `tags` VALUES (74, '人工智能', 'https://lc-gold-cdn.xitu.io/9b525117507d7a76c4ac.png', 'https://juejin.im/tag/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD', 00000116491, 00000007411);
INSERT INTO `tags` VALUES (75, 'Webpack', 'https://lc-gold-cdn.xitu.io/73e856b07f83b4231c1e.png', 'https://juejin.im/tag/Webpack', 00000115726, 00000002075);
INSERT INTO `tags` VALUES (76, 'HTTP', 'https://lc-gold-cdn.xitu.io/936251cc1634d8d98959.png', 'https://juejin.im/tag/HTTP', 00000113169, 00000001517);
INSERT INTO `tags` VALUES (77, 'MySQL', 'https://lc-gold-cdn.xitu.io/b2fbb06dce13eeb3bb9b.png', 'https://juejin.im/tag/MySQL', 00000112590, 00000002550);
INSERT INTO `tags` VALUES (78, '微信小程序', 'https://lc-gold-cdn.xitu.io/a1e7773920f51db40441.png', 'https://juejin.im/tag/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F', 00000107190, 00000002321);
INSERT INTO `tags` VALUES (79, '正则表达式', 'https://lc-gold-cdn.xitu.io/a000ffae9cc85447cba4.png', 'https://juejin.im/tag/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F', 00000103973, 00000001463);
INSERT INTO `tags` VALUES (80, '黑客', 'https://lc-gold-cdn.xitu.io/abd25fb9e6c3941f5ece.png', 'https://juejin.im/tag/%E9%BB%91%E5%AE%A2', 00000101210, 00000001055);
INSERT INTO `tags` VALUES (81, '机器学习', 'https://lc-gold-cdn.xitu.io/a066ea8ec92485ff84e8.png', 'https://juejin.im/tag/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0', 00000099202, 00000003201);
INSERT INTO `tags` VALUES (82, 'jQuery', 'https://lc-gold-cdn.xitu.io/6e09f529abe330fc2392.png', 'https://juejin.im/tag/jQuery', 00000096705, 00000001332);
INSERT INTO `tags` VALUES (83, '创业', 'https://lc-gold-cdn.xitu.io/96a2364285cd9b039219.png', 'https://juejin.im/tag/%E5%88%9B%E4%B8%9A', 00000096362, 00000002045);

SET FOREIGN_KEY_CHECKS = 1;
